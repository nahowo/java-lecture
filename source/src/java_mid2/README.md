# 목차
- 2: [제네릭 1](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-2-%EC%A0%9C%EB%84%A4%EB%A6%AD-1)
- 3: [제네릭 2](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-3-%EC%A0%9C%EB%84%A4%EB%A6%AD-2)
- 4: [컬렉션 프레임워크 - ArrayList](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-4-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---arraylist)
- 5: [컬렉션 프레임워크 - LinkedList](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-5-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---linkedlist)
- 6: [컬렉션 프레임워크 - List](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-6-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---list)
- 7: [컬렉션 프레임워크 - Hash](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-7-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---hash)
- 8: [컬렉션 프레임워크 - HashSet](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-8-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---hashset)
- 9: [컬렉션 프레임워크 - Set](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-9-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---set)
- 10: [컬렉션 프레임워크 - Map, Stack, Queue](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-10-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---map-stack-queue)
- 11: [컬렉션 프레임워크 - 순회, 정렬](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-11-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---%EC%88%9C%ED%9A%8C-%EC%A0%95%EB%A0%AC)

# 섹션 2: 제네릭 1
- 변수 하나로 합치기: control + T에서 8 선택
- 변수명 변경: shift + F6(fn + 터치패드)
### Object의 문제점
- 다운캐스팅이 필수적: 자식 타입은 부모 타입을 담을 수 없기 때문에 Object 객체를 반환 시 다운캐스팅을 통해 원하는 타입으로 변경해야 한다. 
- 잘못된 타입의 인수 전달: setter로 기존 타입이 아닌 다른 타입을 전달 시 컴파일 오류로 확인할 수 없고 런타임 오류가 발생한다. 즉 타입 안정성이 낮다. 
- 중복을 제거하면 타입 안정성이 낮아지고, 타입 안정성을 높이면 코드 재사용성이 낮아진다. 

## 제네릭
- 제네릭의 영어 의미는 일반적인, 범용적인이다.  
- `<>`(다이이몬드)를 사용한 클래스를 제네릭 클래스라고 한다.
- 클래스명 오른쪽에 `<T>` 처럼 선언하면 제네릭 클래스가 된다. T는 타입 매개변수라고 하며, 매개변수이므로 T 말고 다른 이름을 사용해도 된다. 
  - 타입 매개변수는 일반적으로 대문자를 사용하고 용도에 맞는 단어의 첫글자를 사용하는 관례를 따른다.
- T 타입은 이후에 다른 타입으로 변할 수 있다. 
- 인스턴스 생성 시점에 T의 타입(참조형만 가능)을 지정한다. 이후 클래스의 T가 모두 해당 타입으로 변한다. 설정한 타입과 맞지 않으면 컴파일 오류가 발생한다. 즉 타입 안정성을 보장하기 때문에 캐스팅도 필요하지 않다. 
  - 컴파일러가 입력한 타입 정보를 기반으로 컴파일 과정에서 반영한다(실제 해당 타입의 코드가 생성되는 것은 아니다). 
- 제네릭을 사용해 중복 제거와 타입 안정성을 모두 확보할 수 있다. 

### 타입 추론
- 인스턴스 생성 시 `GenericClass<Integer> genericClass = new GenericClass<>()` 처럼 다이아몬드 안에 타입을 생략할 수 있다.
- 타입 추론은 자바 컴파일러가 타입을 추론할 수 있는 상황에서만 가능하다. 즉 주변에 읽을 수 있는 타입 정보가 있어야 추론할 수 있다. 

### 제네릭 용어
- 제네릭의 핵심은 사용할 타입을 미리 정의하지 않는다는 점이다. 메서드 매개변수와 인자의 관계와 비슷하다. 
- 메서드 매개변수와 인자
  - 매개변수(parameter): 중간에서 연결(매개)해주는 변수, 인자를 받아서 처리해줌
  - 인자, 인수(argument): 실제 메서드로 전달되는 값
- **실행 시점에 메서드의 매개변수에 인자를 전달해서 메서드의 사용할 값을 결정한다.**
- 제네릭의 타입 매개변수와 타입 인자
  - 제네릭 클래스 정의 시 내부에서 사용할 타입을 미리 결정하는 것이 아니라, **해당 클래스를 실제 사용하는 생성 시점에 내부에서 사용할 타입을 결정한다.**
- 매서드는 **매개변수**에 **인자**를 전달해서 사용할 값을 결정한다. 
- 제네릭 클래스는 **타입 매개변수**에 **타입 인자**를 전달해서 사용할 타입을 결정한다.
- 제네릭 타입 사용 시 다이아몬드 없이 타입 지정을 생략하면 타입 인자가 Object로 들어간다. 이런 경우를 원시 타입(Row Type)이라고 한다.
  - 제네릭이 없던 과거 코드와의 호환성을 위해 원시 타입을 지원한다. 원시 타입은 위에서 나왔던 타입 안정성 문제 때문에 지양해야 한다.  
- 오버라이딩 단축키: control + O

# 섹션 3: 제네릭 2
## 제네릭의 문제
- 메서드 정의 시점에서는 T의 타입을 알 수 없다. 즉 T에 어떤 타입 인자가 들어올지 모르기 때문에 모든 객체에서 사용 가능한 Object의 메서드만 사용 가능하다.
- T의 타입 인자로 어떤 타입이든 들어올 수 있다.

### 타입 매개변수 제한
- 제네릭 클래스와 관련있는 타입만 타입 인자로 들어오도록 제한할 수 있다. 즉 타입 매개변수를 제한할 수 있다. 
- 타입의 상한을 지정해서 그 외의 타입 인자가 들어오는 것을 컴파일 시점에 막는다. 지정한 상한 타입의 메서드를 제네릭 클래스에서 사용할 수 있다. 

## 제네릭 메서드
- 제네릭 메서드는 클래스 전체가 아니라 특정 메서드 단위로 제네릭을 도입할 때 사용한다. 
- 제네릭 메서드를 정의할 때는 메서드의 반환 타입 왼쪽에 다이아몬드를 사용해 타입 매개변수를 적는다. 
  - `GenericMethod.<Integer>genericMethod(i)`
- 메서드를 실제 호출하는 시점에 다이아몬드를 사용해서 타입을 정하고 호출한다.

### 인스턴스 메서드, static 메서드
- 제네릭 메서드는 인스턴스 메서드와 static 메서드에 모두 적용할 수 있다. 
- 제네릭 타입은 static 메서드에 타입 매개변수를 사용할 수 없다. 제네릭 타입은 객체 생성 시점에 타입이 정해지는데, static 메서드는 인스턴스 단위가 아니라 클래스 단위로 작동하기 때문에 제네릭 타입과 무관하다. 
- 따라서 static 메서드에 제네릭 타입을 도입하려면 제네릭 메서드를 사용해야 한다. 
- 타입 매개변수 제한
  - 제네릭 메서드도 제네릭 타입과 마찬가지로 타입 매개변수를 제한할 수 있다. 
- 타입 추론
  - 타입 인자를 추론할 수 있다. 제네릭 메서드에 타입을 매번 전달하는 것은 번거롭기 때문에 주로 타입 추론을 사용한다. 

### 제네릭 타입 vs 제네릭 메서드
- 클래스의 제네릭 타입보다 제네릭 메서드가 더 높은 우선순위를 가진다. 변수와 더 가깝고 구체적인 제네릭 메서드가 적용된다. 
- 모호한 경우 제네릭 이름을 다르게 변경하는 게 좋다. 

## 와일드 카드
- 컴퓨터 프로그래밍에서 와일드 카드는 하나 이상의 문자들을 상징하는 특수 문자를 의미한다.
- 와일드 카드는 제네릭 타입/제네릭 메서드를 선언하는 것이 아니라, 이미 만들어진 제네릭 타입을 활용할 때 사용한다. 
- 타입 인자가 정해진 제네릭 타입을 전달받아 활용할 때 사용한다. 
- 비제한 와일드 카드는 `<? extends Object>`를 의미한다. 모든 타입을 받을 수 있다. 
- 와일드 카드는 입력받은 타입을 그대로 사용하고 동적으로 변환하거나 타입 매개변수를 결정할 수 없다. 이런 경우에는 제네릭 메서드를 사용해야 한다.

### 상한 와일드 카드
- 와일드 카드에도 상한을 설정할 수 있다. `<? extends {클래스}>`를 이용해 {클래스} 이하 클래스를 모두 사용할 수 있다. 

### 하한 와일드 카드
- 하한을 설정할 수 있다. `<? super {클래스}>`를 이용해 {클래스} 이상 클래스를 모두 사용할 수 있다.

## 타입 이레이저
- 제네릭은 자바 컴파일 단계에서만 사용되고 컴파일 이후에는 제네릭 정보가 삭제된다. 즉 바이트코드 .class에는 타입 매개변수가 존재하지 않는다. 
- 제네릭은 개발자가 직접 캐스팅하던 코드를 컴파일러가 대신 처리해주는 방식이다. 
- 타입 이레이저를 사용하면 런타임 시점에는 제네릭 정보가 제거된 이후이기 때문에 instanceof나 생성자를 사용할 수 없다. 

# 섹션 4: 컬렉션 프레임워크 - ArrayList
## 배열
- 배열에서 인덱스를 이용하면 매우 빠르게(O(1)) 자료를 찾을 수 있다.
  - 배열은 메모리 상에서 원소 순서대로 붙어서 존재한다. 배열의 시작 위치 참조값에서 자료 크기 * 인덱스 번호를 곱하면 원하는 메모리 위치를 찾을 수 있다. 
    - `i번째 인덱스 원소의 주소 = 배열 시작 참조(배열[0]의 주소) + (자료형 크기 * i)` 
- 인덱스를 통해 입력, 변경, 조회를 O(1) 시간에 처리할 수 있다. 
- 배열의 검색
  - 배열의 각 원소값을 찾으려는 값과 비교해야 하기 때문에 O(n)의 시간이 걸린다. 
- 배열에 원소 추가
  - 데이터를 중간에 추가하면 기존 데이터가 오른쪽으로 한 칸씩 이동하기 때문에 O(n)의 시간이 걸린다.
  - 데이터를 맨 끝(오른쪽)에 추가하면 기존 데이터는 변경되지 않고 새 데이터가 들어갈 공간만 확보해서 넣으면 되기 때문에 O(1)의 시간이 걸린다.

## 리스트
- 배열의 불편함은 길이를 동적으로 변경할 수 없고, 데이터를 추가할 때 번거롭다는 점에 있다. 
- 배열의 불편함을 해결하기 위해 리스트를 사용할 수 있다. 
- 배열: 순서가 있고 중복 허용, 크기가 정적으로 고정
- 리스트: 순서가 있고 중복 허용, 크기가 동적으로 변경 가능
- 배열 리스트(ArrayList): 리스트 자료구조를 사용하지만 내부 데이터는 배열에 보관하는 것

# 섹션 5: 컬렉션 프레임워크 - LinkedList
## 노드와 연결 - 연결 리스트(Linked list)
- 배열 리스트는 크기를 동적으로 변경할 수 있지만 삽입/삭제 연산의 경우 데이터의 이동이 필요하다는 단점이 있다. 
- 노드에 next 필드를 추가하고 다음 노드의 참조값을 저장하도록 하면 필요한 만큼만 노드를 만들어서 연결하면 되기 때문에 데이터 삽입에 O(1) 시간이 걸리고 메모리도 절약할 수 있다.  
### 리스트
- 순서가 있고 중복을 허용하는 자료구조이다. 
- `배열 리스트`: 리스트의 내부에서 배열을 사용하는 리스트
- `연결 리스트`: 리스트의 내부에서 노드와 연결 구조를 사용하는 리스트
- 연결 리스트의 인덱스 접근
  - 메모리가 연속되지 않기 때문에 O(n)이 걸린다. 
- 연결 리스트의 검색
  - 모든 데이터를 확인해야 하기 때문에 O(n)이 걸린다. 
- 연결 리스트의 삽입/삭제
  - 마지막 데이터를 찾는 데에 O(n)이 걸리기 때문에 O(n)이 걸린다.
- next 정보를 저장하기 위한 추가 메모리가 사용되지만 비어 있는 원소를 저장해둘 필요가 없기 때문에 메모리가 절약된다. 
- 배열 리스트에서 삽입/삭제 시 전체 데이터를 이동시키는 과정이 필요했다. 연결 리스트에서는 실제 인덱스가 존재하지 않기 때문에 앞, 전, 현재 노드의 next 참조값만 변경해주면 삽입/삭제를 O(1)만에 수행할 수 있다. 

### 배열 리스트 vs 연결 리스트 시간복잡도
| 기능 | 배열 리스트 | 연결 리스트 |
| --- | --- | --- |
| 인덱스 조회 | O(1) | O(n) |
| 검색 | O(n) | O(n) |
| 앞에 추가/삭제 | O(n) | O(1) |
| 뒤에 추가/삭제 | O(1) | O(n) |
| 중간 추가/삭제 | O(n) | O(n) |

# 섹션 6: 컬렉션 프레임워크 - List
## 의존관계 주입(Dependency Injection; DI)
- 데이터를 앞에 추가/삭제하는 일이 많다면 연결 리스트를 사용하는 것이 효율적이다. 
- 특정 클래스가 인터페이스가 아닌 구체적인 클래스를 사용하면 이것을 구체적인 클래스에 의존한다고 표현한다(클래스를 사용하기 위해 구체적인 클래스가 필요). 
- 구체적인 클래스에 직접 의존하면 클래스를 갈아끼울 때마다 여기에 의존하던 클래스 코드도 함께 변경해야 한다. 
- 클래스 코드를 변경하지 않으려면 **구체적인 클래스가 아니라 추상적인 인터페이스에 의존할 수 있다.** 
- `의존관계 주입`: 생성자에 구체적인 클래스를 입력하도록 하여 런타임 시간으로 결정을 미룰 수 있다. 
  - 결과적으로 **클라이언트 코드를 변경하지 않으면서 원하는 전략(구체 클래스)을 런타임에 지정할 수 있다.**
  - 클라이언트 코드의 외부에서 의존관계가 결정되어 구현체가 생성자로 전달된다. 관계가 외부에서 주입되는 것 같아서 의존관계 주입이라고 부른다. 
  - 생성자를 통해 주입되었기 때문에 생성자 의존관계 주입이라고 한다. 

## 의존관계의 종류
- 의존관계는 크게 컴파일 타임 의존관계와 런타임 의존관계로 나뉜다. 

### 컴파일 타임 의존관계
- 컴파일 타임 의존관계는 자바 컴파일러가 보는 의존관계이다. 클래스에 모든 의존관계가 나타나서 바로 확인할 수 있는 관계를 의미한다. 

### 런타임 의존관계
- 런타임 의존관계는 실제 프로그램이 작동할 때 보이는 의존관계이다. 주로 생성된 인스턴스와 그것을 참조하는 의존관계이다. 
- 프로그램이 실행될 때 인스턴스간의 의존관계이다. 
- 런타임 의존관계는 프로그램 실행 동안 계속 바뀔 수 있다.

## 자바 리스트
### 컬렉션 프레임워크 - 리스트
- Collection 인터페이스: java.util 패키지의 컬렉션 프레임워크 핵심 인터페이스 중 하나이다. 데이터 그룹을 다루기 위한 메서드를 정의한다. 
### 자바 ArrayList
- 기본 CAPACITY는 10이고 초과 시 길이를 50%씩 증가시킨다.
- 메모리 고속 복사 연산을 사용해 그냥 복사보다 훨씬 빠르게 수행한다. System.arraycopy()를 사용한다. 
### 자바 LinkedList
- 이중 연결 리스트 구조이다. 마지막 노드에 대한 참조도 제공해서 끝에 추가하는 경우 O(1)이 걸린다. 역방향 조회도 가능하다.

# 섹션 7: 컬렉션 프레임워크 - Hash
## 리스트(List) vs 세트(Set)
- 리스트: 요소들의 순차적인 컬렉션이다. 
  - 순서 유지
  - 중복 허용
  - 인덱스 접근
- 세트: 유일한 요소들의 컬렉션이다. 
  - 유일성(중복 허용 X)
  - 순서 미보장(인덱스 X)
  - 빠른 검색

## 해시 알고리즘
- 데이터 값을 인덱스 자체로 이용하면 검색을 O(1) 시간에 수행할 수 있다. 
- 대신 데이터 값의 범위만큼 배열을 할당해야 하기 때문에 메모리가 낭비되는 문제가 발생한다. 

### 나머지 연산 - 해시 인덱스
- 위의 문제를 해결하기 위해 나머지 연산을 사용한다. 
- 해시 인덱스: 배열의 인덱스로 사용하기 위해 원래의 값을 계산한 인덱스
- 해시 인덱스를 사용하면 메모리 문제를 해결할 수 있다. 
### 해시 충돌
- 다른 데이터가 같은 해시 인덱스를 가지게 된다면 해시 충돌이 일어난다. 
- 해시 충돌은 낮은 확률로 일어날 것이라고 가정한 뒤, 해시 충돌이 일어났을 때 충돌이 일어난 값들을 같은 해시 인덱스에 저장한다. 
- 배열을 사용했다면 하나의 인덱스에 여러 값을 저장하는 배열/리스트 등을 사용해 여러 값을 저장할 수 있다.
- 만약 모든 값이 같은 해시 인덱스에 저장된다면 최종 시간복잡도는 O(n)이 된다. 하지만 확률적으로 해시 인덱스가 넓게 펼쳐지기 때문에 대부분의 경우에는 O(1)으로 데이터를 검색할 수 있다. 
- 해시 알고리즘에 사용되는 CAPACITY값이 너무 작다면 해시 충돌이 빈번해지고, 너무 크다면 메모리가 낭비된다. 
  - 통계적으로 입력한 데이터의 수가 배열 크기의 75%를 넘지 않으면 해시 충돌이 잘 발생하지 않는다. 

# 섹션 8: 컬렉션 프레임워크 - HashSet
- LinkedList.remove() 사용 시 주의점: LinkedList의 remove는 remove(int i), remove(Object o)로 두 가지가 있다. 이때 int값을 전달하면 해당 인덱스 값을 삭제하기 때문에 래퍼 타입으로 변환해 제거해야 값이 정상적으로 제거된다.
- 문자열 해시코드
  - 문자 기반 숫자 해시 인덱스를 구하기 위해 문자열 해시코드를 사용한다. 

### 용어 정리
- **해시 함수(Hash Function)**: 임의의 길이의 데이터를 입력받아 고정 길이의 해시값(해시 코드)을 출력하는 함수
  - 고정 길이는 저장 공간의 크기를 뜻한다. 
  - 같은 데이터를 입력하면 항상 같은 해시 코드를 반환한다. 
  - 다른 데이터를 입력해도 같은 해시 코드가 나올 수 있다. 이를 해시 충돌이라고 한다. 
- **해시 코드(Hash Code)**: 데이터를 대표하는 값을 통한다. 주로 해시 함수를 통해 만들어지는 값을 말한다. 
- **해시 인덱스(Hash Index)**: 데이터의 저장 위치를 결정하는 값이다. 주로 해시 코드 결과에 배열의 길이를 나누어 구한다. 

## 자바의 hashCode()
- 사용자 정의 타입을 포함해 모든 타입에 대한 해시 코드를 구하기 위해 자바는 hashCode()를 제공한다. 
- hashCode() 메서드만 오버라이딩하면 모든 타입에 대한 해시 코드를 원하는 방식으로 구할 수 있다.
- 변수 한 줄로 합치기: option + cmd + N

### equals(), hashCode()
- 해시 인덱스가 같아도 실제 저장된 데이터는 다를 수 있다. 즉 같은 위치에 다른 값이 저장될 수 있다. 여기서 데이터를 구분하기 위해 `equals()`를 사용한다. 
- Object의 기본 메서드
  - hashCode(): 객체의 참조값을 기반으로 해시 코드 반환
  - equals(): == 동일성 비교 수행(참조값이 같아야 true 반환)감
- **기본 메서드는 참조값을 기반으로 결과를 반환하기 때문에 항상 equals(), hashCode() 메서드를 오버라이드해서 사용해야 한다.** 

# 섹션 9: 컬렉션 프레임워크 - Set
### Set 인터페이스
- java.util 패키지의 컬렉션 프레임워크에 속하는 인터페이스 중 하나이다. 
- 중복을 허용하지 않는 요소들의 집합을 나타내고 순서를 보장하지 않는다. 특정 요소가 집합에 있는지 여부를 확인하는 데 최적화되어 있다. 
- HashSet, LinkedHashSet, TreeSet 등의 여러 구현 클래스를 가진다. 

## HashSet
- 해시 자료구조를 이용해 Set을 구현한다.
- 순서를 보장하지 않고 주요 연산에 O(1) 시간이 걸린다. 
- 재해싱(rehashing)
  - 데이터가 배열 크기의 75%를 넘어가면 해시 충돌이 자주 발생한다. 이를 해결하기 위해 배열의 크기를 2배로 늘리고, 늘린 크기를 기준으로 해시 인덱스를 다시 적용한다. 시간이 걸리지만 해시 충돌이 줄어들게 된다. 
  - 재해싱의 횟수를 줄이기 위해 capacity를 한번에 2배씩 증가시킨다. 
- 자바 HashSet의 기본 크기는 16이다. 
- 실무에서 Set이 필요한 경우 HashSet을 가장 많이 사용한다. 

## LinkedHashSet
- Set 자료구조는 기본적으로 순서를 보장하지 않는다고 가정한다. 하지만 LinkedHashSet에서는 데이터가 추가된 순서대로 유지된다. 
- 주요 연산에 O(1) 시간이 걸린다.
- 연결 링크를 유지해야 하기 때문에 HashSet보다 조금 무겁다. 
- HashSet과 LinkedList를 합친 개념이다. 
- 원소에 노드를 저장하고, 입력된 순서대로 next/pre(양방향) 링크를 연결한다. 링크를 순서대로 따라가면 입력 순으로 조회할 수 있다. 

## TreeSet
- 레드-블랙 트리를 내부에서 사용한다. 
  - 노드의 왼쪽 자손은 현재값보다 작은 값, 오른쪽 자식은 현재값보다 큰 값을 가진다. 
- 요소가 정렬된 순서로 저장된다. 
- 시간복잡도가 O(logN)이다. 

# 섹션 10: 컬렉션 프레임워크 - Map, Stack, Queue
## Map
- Key, Value로 이루어져 있다.
- Key는 중복을 허용하지 않고 Value는 중복을 허용한다. 
- 순서를 보장하지 않는다. 
- Map 인터페이스에는 HashMap, LinkedMap, TreeMap 등 다양한 구현체를 제공한다. 
- Set과 동일하게 사용자 생성 객체를 key값으로 사용할 경우 무조건 equals(), hashCode()를 구현해야 한다. 

### Map 구현체
- Map은 key가 있는 Set과 동일하므로 구현체도 비슷하게 구성된다. 

### HashMap
- HashSet은 HashMap의 구현을 사용하며 Value만 비워두고 사용한다. 

### LinkedMap
- HashMap과 유사하지만 연결 리스트를 사용해 삽입 순서/최근 접근 순서에 따라 요소를 유지한다. 

### TreeMap
- 레드-블랙 트리 기반의 자료구조를 가진다. 
- 키가 정렬된 순서로 저장된다. 
- 주요 작업들의 시간복잡도는 O(logN)이다. 

## Stack
- Stack은 후입선출 구조를 가지는 자료구조이다. 
- push/pop
- 자바에서 스택을 사용하려면 Stack 클래스 대신 Deque 클래스를 사용하는 것이 좋다. 

## Queue
- Queue는 선입선출 구조를 가지는 자료구조이다. 
- offer/poll/peek

## Deque
- Double-End Queue의 약자이다. 
- 양쪽 끝에서 선입선출이 가능한 자료구조이다. 큐와 스택의 기능을 다 가지고 있다. 
- offerFirst/offerLast/pollFirst/pollLast/peekFirst/peekLast

### ArrayDeque vs LinkedDeque
- ArrayList와 LinkedList의 차이와 비슷하다. 
- ArrayList는 원형 큐 자료구조를 사용해 앞/뒤 입력에 O(1)이 소요된다. 
- 일반적으로 ArrayList가 실제 사용 환경에서 더 나은 성능을 보인다. 

## Deque, Stack, Queue
- Deque는 Stack, Queue의 메서드까지 제공한다. 
- Stack의 경우 Deque보다 느리기 때문에 Deque를 사용한다. 

# 섹션 11: 컬렉션 프레임워크 - 순회, 정렬
## 순회 - Iterator, Iterable
- 자료구조별 데이터 접근 방식이 다르기 때문에 순회 방식도 다르다. 
- 자바는 이 문제를 해결하기 위해 Iterable과 Iterator 인터페이스를 제공한다. 

### Iterable
- 반복 가능하다는 뜻이다. 
- 주요 메서드
  - `iterator()`: `Iterator` 반복자를 반환한다. 
- Iterable 인터페이스를 구현하면 반복할 수 있는 클래스가 된다. 
- Iterable 인터페이스를 구현하면 iterator() 메서드를 구현해야 한다. 여기서 Iterator 인터페이스를 구현한 반복자를 반환한다. 

### Iterator
- 반복자라는 뜻이다. 
- 주요 메서드
  - `hasNext()`: 다음 요소가 있는지 확인한다. 
  - `next()`: 다음 요소를 반환한다. 내부 위치를 다음 위치로 이동한다. 

### 향상된 for문
- 향상된 for문을 사용하려면 Iterable을 구현해야 한다. 

## 자바가 제공하는 Iterable, Iterator
- 자바 컬렉션 프레임워크는 Iterable 인터페이스를 제공하고, 리스트, 세트 등 각 구현체에 맞는 Iterator을 구현해두었다.

## 정렬 - Comparable, Comparator
- 자바는 데이터가 작을 때(32개 이하) 듀얼 피벗 퀵소트(Dual Pivot Quick Sort)를 사용하고, 데이터가 많다면 팀소트(Tim sort)를 사용한다. 
- 사용자 객체를 정렬하기 위해 Comparable 인터페이스를 구현해서 두 객체 중 어떤 것이 크다고 간주할지 정의할 수 있다. 
- 객체의 기본 정렬 방법은 객체에 Comparable을 구현해서 정의한다. 이러면 객체는 비교할 수 있는 객체가 되고, 기본 정렬 방법을 가지게 된다. 
- 기본 정렬 외에 다른 정렬 방법을 사용해야 하는 경우 비교자(Comparator)를 별도로 구현해 정렬 메서드에 전달한다.
- 자바가 제공하는 Integer, String 같은 기본 객체들은 대부분 Comparable을 구현해 두었다. 

### Arrays.sort()
- 기본 정렬은 `Arrays.sort(배열)`처럼 인자로 정렬하려는 배열을 넘겨주면 된다. 
- 정렬 방식을 `지정하고 싶다면 Arrays.sort(배열, 비교자)`처럼 인자로 정렬하려는 배열과 비교자(Comparator)를 넘겨주면 된다. 비교자는 Comparator를 구현해야 한다. 

### List 정렬
- 기본 정렬자의 경우 `list.sort(null)`처럼 인자로 null을 넘겨서 사용한다. 다른 정렬자를 사용할 경우 비교자를 인자로 넘겨서 사용한다. 

### Tree 정렬
- Tree는 원소가 들어올 때부터 정렬 상태를 유지하기 때문에 정렬 방식을 생성할 때 전달해야 한다. 
  ```java
  TreeSet<MyUser> treeSet1 = new TreeSet<>(new IdComparator());
  ```

## 컬렉션 Utils
### 가변 컬렉션 <-> 불변 컬렉션
- `List.of(원소 1, 원소 2, ...)`같은 식으로 생성하면 **불변 컬렉션**을 생성할 수 있다. 
- `List<Integer> 가변 리스트 = new ArrayList<>(불변 리스트)`를 하면 불변 리스트를 가변 리스트로 변경할 수 있다.
- `List<Integer> 불변 리스트 = Collections.unmodifiableList(가변 리스트)`를 하면 다시 가변 리스트를 불변 리스트로 변경할 수 있다.

## 실무 선택 가이드
- List의 경우 대부분 ArrayList
  - 데이터가 매우 크고 앞쪽에서 연산이 많이 일어나는 경우 LinkedList
- Set의 경우 대부분 HashSet
- Map의 경우 대부분 HashMap
- Queue의 경우 대부분 ArrayDeque