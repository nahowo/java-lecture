# 목차
- 2: [클래스와 데이터](https://github.com/nahowo/java-start/tree/main/source/src/java_basic#%EC%84%B9%EC%85%98-1-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0)
- 3: [기본형과 참조형](https://github.com/nahowo/java-start/tree/main/source/src/java_basic#%EC%84%B9%EC%85%98-3-%EA%B8%B0%EB%B3%B8%ED%98%95-vs-%EC%B0%B8%EC%A1%B0%ED%98%95)
- 4: [객체 지향 프로그래밍](https://github.com/nahowo/java-start/tree/main/source/src/java_basic#%EC%84%B9%EC%85%98-4-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
- 5: [생성자](https://github.com/nahowo/java-lecture/blob/main/source/src/java_basic/README.md#%EC%84%B9%EC%85%98-5-%EC%83%9D%EC%84%B1%EC%9E%90)
- 6: [패키지]()
- 7: [접근 제어자]()
- 8: [자바 메모리 구조와 static]()
- 9: [final]()
- 10: [상속]()
- 11: [다형성1]()
- 12: [다형성2]()
- 13: [다형성과 설계]()

# 섹션 2: 클래스와 데이터
### 클래스가 필요한 이유
- 배열 사용의 한계: 데이터 타입별 배열을 생성해야 한다. 원소의 변경이 일어날 때 관리하기 매우 어렵다. 
- 사람이 관리하기 좋은 방식은 특정 개념을 하나로 묶는 것, 개념에 해당하는 데이터를 한번에 관리하는 것

### 클래스 도입
- `class` 키워드를 사용해 클래스를 정의할 수 있다. 
- 개념을 구성하는 데이터를 클래스 내부에 변수로 정의할 수 있다. 
- `멤버 변수` 또는 `필드`: 클래스 내부에 정의한 변수
- 클래스는 관례상 대문자로 시작, 카멜케이스 사용

### 클래스와 사용자 정의 타입
- 사용자 정의 타입의 설계도가 클래스
- 설계도를 사용해 실제 메모리에 만들어진 실체가 `객체` 또는 `인스턴스`

### 실습
1. 변수 선언
    ```java
    Student student;
    ```
  - Student 타입을 담을 수 있는 변수를 생성한다. 
2. 인스턴스(객체) 생성
    ```java
    student = new Student();
    ```
  - new 키워드를 사용해 메모리에 실제 Student 인스턴스를 생성한다. 클래스의 멤버 변수가 들어갈 메모리 공간도 함께 확보한다. 
3. 참조값 보관
   - 인스턴스를 생성하면 메모리 어딘가에 있는 이 객체에 접근할 수 있는 참조값(주소)을 반환한다. 해당 참조값이 student 변수에 저장된다. 
   - 생성한 객체에 접근하기 위해 주소값을 사용한다.

### 객체 사용
- 객체의 멤버 변수에 접근하기 위해 .을 사용한다. 
- 객체에 접근하기 위해 `객체 변수.` 키워드를 사용하면 변수의 참조값을 이용해 메모리에 존재하는 객체에 접근한다.

## 클래스, 객체, 인스턴스
### 클래스 Class
- 클래스는 객체를 생성하기 위한 틀 또는 설계도이다. 객체가 가져야 할 속성과 기능을 정의한다.

### 객체 Object
- 객체는 클래스에서 정의한 속성과 기능을 가진 실체이다. 객체는 서로 독립적인 상태를 가진다. 

### 인스턴스 Instance
- 인스턴스는 특정 클래스로부터 생성된 객체를 의미한다. 객체와 인스턴스는 자주 혼용된다. 
- 인스턴스는 주로 객체가 어떤 클래스에 속해 있는지 강조할 때 사용한다. (예: A 클래스의 인스턴스)
- 모든 인스턴스는 객체이지만 그 객체가 특정 클래스로부터 생성되었다는 점을 강조하고 싶을 때 사용할 수 있다. 

# 배열
- 클래스를 원소로 가지는 배열을 생성할 수 있다.
   ```java
    Student[] students = new Student[3];
    students[0] = student1;
    students[1] = student2;
    students[2] = student3;
   ```
- 객체의 인스턴스 변수는 해당 인스턴스의 주소값을 가지기 때문에 클래스 배열의 각 원소에도 각 인스턴스의 주소값이 들어간다. 
- **자바에서의 대입은 항상 변수에 들어있는 값을 복사해서 대입한다.**
  - 변수에는 참조값이 들어가기 때문에 인스턴스 자체가 복사되는 것이 아니라 주소값이 복사된다. 

### 배열에 들어있는 객체 사용
- 배열이 가리키는 주소값(배열의 주소값) 접근 -> 배열의 원소가 가리키는 주소값(인스턴스의 주소값) 접근 -> 해당 주소값의 객체의 변수 접근


# 섹션 3: 기본형 vs 참조형
- 변수의 데이터 타입은 크게 두 가지로 구분할 수 있다. 
1. 기본형(primitive type): 변수에 사용할 값을 직접 넣을 수 있는 데이터 타입
2. 참조형(reference type): 변수에 데이터에 접근하기 위한 참조 주소를 저장하는 데이터 타입
### 기본형 vs 참조형 - 기본
- 기본형에는 실제 사용하는 값이 변수에 들어간다. 값을 바로 사용할 수 있다. 
- 참조형에는 실제 객체의 위치(주소)가 들어간다. 참조형은 객체와 배열이 있다. 
  - 객체는 .을 통해 메모리 상에 생성된 객체를 찾아가야 사용할 수 있다. 
  - 배열은 []를 통해 메모리 상에 생성된 배열을 찾아가야 사용할 수 있다. 
- 기본형은 소문자로 시작한다. int, long, char등은 기본형이다. 기본형은 개발자가 정의할 수 없다. 
- 개발자는 클래스(참조형)만 정의할 수 있다. String, Integer는 참조형이고, 개발자가 작성하는 클래스도 대문자로 시작하는 관례를 따른다.  
### 기본형 vs 참조형 - 계산
- 기본형은 값 그대로 사용할 수 있다. 
- 참조형은 참조값 그대로 사용할 수 없다. 주소지에 방문해 실제 값에 접근해야 연산을 수행할 수 있다.

### 기본형 vs 참조형 - 변수 대입
**자바에서는 변수의 값을 복사해서 대입한다.**
- 기본형 대입: 변수에 들어있는 실제 값을 복사해서 대입한다. 
- 참조형 대입: 변수에 들어있는 참조값을 복사해서 대입한다.
  - 같은 객체를 참조한다면 변수의 개수와 상관없이 실제 메모리상의 객체는 하나로 유지된다.

### 기본형 vs 참조형 - 메서드 호출
- 메서드 호출도 대입과 동일하다. 메서드 호출 시 사용하는 매개변수(파라미터)도 변수이다. 메서드를 호출할 때 매개변수에 값을 전달하는 것도 설명한 내용과 같이 값을 복사해서 사용한다.
- 기본형의 경우 매개변수로 값을 전달할 때에도 현재 변수의 값을 복사해서 사용한다. 메서드 내에서 변수의 값을 변경시켜도 다른 값을 사용하므로 호출자의 값은 변경되지 않는다. 
- 참조형의 경우 주소값을 복사해서 전달하기 때문에 같은 객체에 접근한다. 메서드 내에서 변수의 값을 변경시킨다면 호출자의 객체도 같은 주소를 가리키므로 변경이 적용된다. 

## 변수와 초기화
- 멤버 변수: 클래스 내부에서 사용되는 변수
- 지역 변수: 메서드에 선언되는 변수, 매개변수도 지역 변수에 포함
### 변수의 값 초기화
- 멤버 변수: 자동 초기화
  - 인스턴스의 멤버 변수는 인스턴스를 생성할 때 변수형의 기본값으로 초기화된다. 
  - 개발자가 초기값을 지정할 수 있다. 
- 지역 변수: 수동 초기화
  - 항상 직접 초기화해야 한다.

### null
- 참조형 변수에는 아직 가리키는 대상이 없을 때 null값이 들어간다. 
### GC
- 어떤 변수도 참조하지 않는 인스턴스는 해당 주소를 다시 구할 방법이 없다. 따라서 해당 인스턴스에 접근할 방법이 없고, 메모리 용량만 차지하게 된다. 
- 이런 인스턴스를 메모리에서 제거하기 위해 가비지 컬렉션이 사용된다. 
- 객체는 해당 객체를 참조하는 곳이 있으면 JVM이 종료될 때까지 생존한다. 중간에 어떤 객체를 참조하는 변수가 없어지면 해당 객체를 GC가 메모리에서 제거한다.

### NullPointerException
- 참조값 없이 객체를 찾아가면 null을 가리키는(pointer) 예외가 발생한다. 
- 객체를 참조할 때 .을 사용하는데, 이때 참조값이 null이라면 NullPointerException이 발생한다.

# 섹션 4: 객체 지향 프로그래밍
- 절차 지향 프로그래밍: 절차를 지향, 실행 순서를 중요하게 생각하는 방식, "어떻게"가 중심
- 객체 지향 프로그래밍: 객체를 지향, 실세계의 사물이나 사건을 객체로 보고 그 상호작용을 중요하게 생각하는 방식, "무엇을"에 중심
- 절차 지향 프로그래밍의 한계는 데이터와 기능이 분리되어 있다는 점이다. 객체 지향을 통해 기능과 그 기능에 관련된 데이터를 묶을 수 있다.

### 클래스와 메서드
- 클래스 내부에 메서드를 정의하면 기본적으로 멤버 변수를 사용한다.

# 섹션 5: 생성자
### this
- 인스턴스 내부에서 현재 인스턴스를 접근할 때 사용한다. 
- 인스턴스의 멤버 변수와 메서드의 매개변수 이름이 같다면 더 안쪽에 위치하는 매개변수가 우선순위를 가진다. 이때 멤버 변수에 접근하기 위해 `this.{멤버 변수}`를 사용한다.
- 최근 IDE가 발전하면서 멤버 변수와 매개변수를 구분해줌, 모든 멤버 변수에 this를 추가하지 않아도 됨

### 생성자 - 도입
- 객체를 생성함과 동시에 초기값을 할당하는 경우가 많다. 
- 생성자의 이름은 클래스 이름과 같아야 한다. 
- 생성자는 반환 타입 없이 비워두어야 한다.
- 파라미터 정보 확인하는 단축키: cmd + P
### 생성자 호출
- 생성자는 인스턴스 생성 후(new 키워드 사용) 즉시 호출한다. 
  - `new 생성자명(생성자에 맞는 인수 목록)`
  - 생성자를 따로 생성하지 않으면 기본 생성자를 사용한다. 즉 기존에 객체를 생성할 때 사용했던 `new 클래스명()`도 기본 생성자를 호출한 것이다.
### 생성자 장점
- 생성 직후 필요한 작업을 한번에 처리해 코드 중복 제거
- 생성자 호출을 필수로 제약: 선언만 되고 할당이 되지 않아 아무런 정보가 없는 변수가 시스템에 등장하는 것을 막음
  - 직접 정의한 생성자가 있다면 무조건 생성자를 호출해야 함, 호출하지 않는다면 컴파일 오류가 발생 -> 즉 필수값 입력을 보장할 수 있음

## 기본 생성자
- 자바 컴파일러는 클래스에 생성자가 하나도 없다면 자동으로 아무런 작동도 하지 않는 기본 생성자를 작성한다. 
  - 생성자를 작성하지 않은 클래스를 컴파일하면 .class 파일에 기본 생성자가 작성되어 있는 것을 확인할 수 있다.  
- 하지만 클래스에 생성자가 하나라도 있다면 기본 생성자는 생성되지 않는다.

## 생성자 - 오버로딩과 this()
- 생성자도 메서드 오버로딩처럼 매개변수의 조합을 변형하여 여러 생성자를 작성할 수 있다. 
### this()
- 생성자 내부에서 자신의 생성자를 호출한다. 생성자들의 중복을 줄여준다. 
- 생성자 코드의 첫번째 줄에만 작성할 수 있다. 이외의 경우 컴파일 오류가 발생한다. 

# 섹션 6: 패키지
- 파일을 분류하기 위해 폴더/디렉토리라는 개념을 제공하는데, 자바에서는 이를 패키지로 제공한다. 
### 패키지 사용
- 패키지를 사용하는 경우 해당 클래스가 어떤 패키지에 속하는지 파일의 첫 줄에 명시해줘야 한다.
- `import`를 사용해 코드에서 패키지명을 생략하고 클래스를 사용할 수 있다. `패키지.*`을 사용하면 해당 패키지 내의 모든 클래스를 사용할 수 있다.
- 클래스 이름이 같아도 패키지를 포함한 전체 경로가 다르다면 다른 클래스로 인식한다.
- 서로 다른 경로의 같은 이름을 가지는 클래스를 한번에 사용한다면 import는 둘 중 하나만 사용할 수 있다.

## 패키지 규칙
- 패키지 이름, 위치는 실제 디렉토리 위치는 일치해야 한다. 
- 패키지 이름은 모두 소문자를 사용한다. (관례) 
- 패키지 이름의 앞 부분에는 회사의 도메인 이름을 거꾸로 사용한다. (관례)
  - 오픈소스나 라이브러리로 코드를 공유한다면 꼭 지키는 것이 좋다. 
- 패키지는 계층 구조를 이루지만 import문을 사용해야 한다는 점은 변하지 않는다.

## 패키지 활용
- 