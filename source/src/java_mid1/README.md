# 목차
- 2: [Object 클래스](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid1#%EC%84%B9%EC%85%98-2-object-%ED%81%B4%EB%9E%98%EC%8A%A4)
- 3: [불변 객체](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid1#%EC%84%B9%EC%85%98-3-%EB%B6%88%EB%B3%80-%EA%B0%9D%EC%B2%B4)
- 4: [String 클래스](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid1#%EC%84%B9%EC%85%98-4-string-%ED%81%B4%EB%9E%98%EC%8A%A4)
- 5: [래퍼, Class 클래스](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid1#%EC%84%B9%EC%85%98-5-%EB%9E%98%ED%8D%BC-class-%ED%81%B4%EB%9E%98%EC%8A%A4)
- 6: [열거형 - ENUM](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid1#%EC%84%B9%EC%85%98-6-%EC%97%B4%EA%B1%B0%ED%98%95---enum)
- 7: [날짜와 시간](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid1#%EC%84%B9%EC%85%98-7-%EB%82%A0%EC%A7%9C%EC%99%80-%EC%8B%9C%EA%B0%84)
- 8: [중첩 클래스, 내부 클래스 1](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid1#%EC%84%B9%EC%85%98-8-%EC%A4%91%EC%B2%A9-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4-1)
- 9: [중첩 클래스, 내부 클래스 2](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid1#%EC%84%B9%EC%85%98-9-%EC%A4%91%EC%B2%A9-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%82%B4%EB%B6%80-%ED%81%B4%EB%9E%98%EC%8A%A4-2)
- 10: [예외 처리1 - 이론](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid1#%EC%84%B9%EC%85%98-10-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC1---%EC%9D%B4%EB%A1%A0)
- 11: [예외 처리2 - 실습](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid1#%EC%84%B9%EC%85%98-11-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC2---%EC%8B%A4%EC%8A%B5)

# 섹션 2: Object 클래스
## java.lang 패키지
- 자바가 기본으로 제공하는 라이브러리 중 기본이 되는 패키지이다. 
- java.lang 패키지의 대표 클래스
  - `Object`: 모든 자바 객체의 부모 클래스
  - `String`: 문자열
  - `Integer`, Long, Double 등: 기본형 데이터 타입을 래핑해 객체로 만든 것
  - `Class`: 클래스 메타 정보
  - `System`: 시스템 관련 기본 기능 제공
- java.lang은 import 구문을 사용하지 않아도 된다. 
## Object 클래스
- 모든 클래스의 최상위 부모 클래스는 항상 Object이다. 
- 클래스가 상속받는 부모 클래스가 없다면 묵시적으로 Object 클래스를 상속받는다. 상속받는 클래스가 존재한다면 Object를 상속받지 않는다. 
  - 상위 계층으로 올라가다 보면 최상위에는 Object가 존재하게 된다. 즉 모든 클래스는 Object의 직계 자손(묵시적)이거나 후손(명시음)이 된다. 
### Object가 최상위 클래스인 이유
- **공통 기능 제공**
  - 모든 객체에게 필요한 공통 기능을 일관성있게 제공
  - `toString()`: 객체 정보 제공
  - `equals()`: 객체 동등 비교
  - `getClass()`: 객체의 클래스 정보 제공
- **다형성의 기본 구현**
  - 부모는 자식을 담을 수 있음 -> Object는 모든 객체를 참조할 수 있음
  - 다형성을 지원하는 기본적 매커니즘 제공, 모든 객체를 Object 타입으로 편리하게 처리

## Object 다형성
- Object는 모든 객체를 대상으로 다형적 참조를 할 수 있다. 
- Object를 통해 전달받은 객체를 호출하려면 해당 객체에 맞는 다운캐스팅이 필요하다. 
  - Object는 전달받은 객체의 메서드를 알지 못하므로 Object의 메서드를 제외한 메서드에는 오버라이딩을 활용할 수 없다. 

## Object 배열
- Object 타입을 원소로 가지는 배열에는 자바의 모든 클래스가 들어갈 수 있다. 

## toString()
```java
  public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
  }
```
- 패키지를 포함한 객체의 이름, 참조값(해시코드)을 16진수로 표현한다. 
- System.out.println, print등은 내부적으로 toString()을 호출한다. 

## Object와 OCP
- Object는 공통의 부모 역할을 통해 모든 객체들 간 관계를 생성해준다.
- 자바는 객체의 정보를 사용할 때 다형적 참조 문제를 해결해 줄 Object 클래스와 메서드 오버라이딩 문제를 해결해 줄 toString() 메서드가 있다. 
- 다형적 참조
  - Object 타입을 매개변수로 사용해 다형적 참조를 사용한다. 
- 메서드 오버라이딩
  - Object 클래스를 상속하는 구체적인 클래스는 toString() 메서드를 오버라이딩할 수 있다. 
  - 구체적인 타입에 의존하지 않고 런타임 동안 각 인스턴스의 toString()을 호출할 수 있다. 
### System.out.println()
- System.out.println()도 Object 매개변수를 사용하고 내부에서 toString()을 호출한다. 즉 모든 자바 객체를 편리하게 출력할 수 있다. 

## equals() - 동일성과 동등성
- `동일성(Identity)`: 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인
- `동등성(equality)`: 두 객체가 논리적으로 동등한지 확인, 즉 값이 같은지 확인

# 섹션 3: 불변 객체
## 기본형과 참조형의 공유
- **기본형**은 값을 절대 공유하지 않는다. 
- **참조형**은 하나의 객체를 참조값(주소값)을 통해 여러 변수에서 공유할 수 있다. 

## 공유 참조와 사이드 이펙트
- 사이드 이펙트(side effect): 어떤 계산이 주된 작업 외에 추가적인 부수 효과를 일으키는 것
- 여러 변수가 하나의 객체를 공유하는 것을 막을 방법은 없다. 
- 같은 객체를 공유하지 않으면 사이드 이펙트가 발생하지 않는다. 
- 참조값 공유를 막을 수 있는 방법이 없다. 

## 불변 객체 - 도입
**- 사이드 이펙트가 발생하는 이유는 공유 참조 자체 때문이 아니라 공유 참조하는 인스턴스의 값을 변경하기 때문에 발생한다.** 
- 객체 참조값에 `final` 키워드를 적용해도 객체의 상태는 변경시킬 수 있었다. 불변 객체를 사용해 객체의 상태도 변경할 수 없도록 만들 수 있다.
- 특정한 키워드 없이 객체의 상태를 변경할 수 없도록 객체를 설계하면 된다. 
  - setter 메서드를 제거한다. 멤버 변수에 `final`을 적용하면 실수로 setter를 만드는 일을 피할 수 있다. 
  - 사이드 이펙트가 발생할 가능성을 컴파일 오류로 막는다. 
- 즉 **변경을 사용하기 위해서는 다른 인스턴스를 참조**하도록 하여 사이드 이펙트를 없엘 수 있다. 

### withX()
- 관례로 withX() 메서드는 원본 객체 상태가 그대로 유지되면서 X의 값만 변형되는 불변 객체 메서드임을 뜻한다. 

### 불변 객체가 중요한 이유
- 자바에서 가장 많이 사용되는 String, Integer, LocalDate등이 불변 객체이다. 

# 섹션 4: String 클래스
## String 생성
- String은 클래스이지만 편의상 `new` 키워드 외에 "" 안에 문자열을 넣어서 생성하는 방식도 허용한다. 
- String은 너무 자주 쓰이기 때문에 문자열 연결 시 concat 외에도 +연산자를 허용한다. 

### 비교
- 클래스이기 때문에 동일 비교(--)는 false
- 동등 비교(equals)는 따로 오버라이딩되어 true
- **문자열 리터럴 비교**
  - new String 사용 대신 ""를 사용해 문자열 리터럴을 만들면 자바는 메모리 효율성과 성능 최적화를 위해 문자열 풀을 사용한다. 
  - 자바 실행 시점에 문자열 리터럴이 존재하면 문자열 풀에 String 인스턴스를 미리 만들어둔다. 프로그램이 실행되면 문자열 풀에 존재하는 인스턴스를 찾아 참조값을 반환한다. 
- 문자열이 생성자로 생성되었는지 문자열 리터럴인지 확신할 수 없기 때문에 항상 동등 비교를 통해 문자열을 비교해야 한다. 

## String 클래스 - 불변 객체
- String 클래스는 불변 객체이다. String의 byte 배열은 final로 선언되어 있다. 
- **변경이 필요한 경우(concat 등) 기존 값을 변경하지 않고 새 결과를 만들어 반환한다.**
- 불변인 이유
  - 문자열 풀의 객체를 변경할 수 있다면 해당 문자열 리터럴을 사용하는 모든 객체에게 사이드 이펙트를 일으키게 된다. 

## StringBuilder - 가변 String
- 문자열을 자주 변경하면 시스템의 자원을 많이 사용하게 되는데, 가변 String을 이용해 이를 최적화할 수 있다.  
- 변경이 종료되면 toString() 메서드를 이용해 불변 상태로 만들어주는 것이 좋다. 

## String 최적화
- 자바 컴파일러는 문자열 리터럴을 더하는 부분을 자동으로 합쳐준다. 런타임 시간에는 결합 연산을 수행하지 않아도 된다. 
- 변수의 경우 어떤 값이 들어있는지 알 수 없기 때문에 컴파일 시간에 처리할 수 없다. 이 때는 StringBuilder를 통해 최적화를 수행한다. 
- StringBuilder 사용하는 것이 좋은 경우
  - 반복문에서 반복적으로 문자를 연결할 때
  - 대용량 문자열을 다룰 때
  - 조건문을 통해 동적으로 문자열을 조합할 때
  - 복잡한 문자열의 특정 부분을 변경해야 할 때

## 메서드 체이닝
- 스스로를 반환하는 메서드를 사용하면 메서드 체이닝을 통해 중간 반환값을 담아두지 않아도 된다. 메서드 체이닝은 코드 가독성을 높여주고 편리하게 사용할 수 있다.
- StringBuilder는 메서드 체이닝을 제공한다. 

# 섹션 5: 래퍼, Class 클래스
### 기본형의 한계
- 객체가 아님
  - 기본형은 객체가 아니기 때문에 객체 지향 프로그래밍의 장점을 살릴 수 없다. 메서드를 가질 수 없다. 
- null 값 불가능
  - 기본형은 항상 값이 존재해야 하기 때문에 데이터가 없다는 표현이 불가능하다. 

## 자바의 래퍼 클래스
- 자바는 기본형에 대응하는 래퍼 클래스를 제공한다. 래퍼 클래스는 기본형의 객체 버전이다. 
- Byte, Short, Integer, Long, Float, Double, Character, Boolean
- 불변 객체이며 equals로 비교해야 한다. 
- Integer
  - new 키워드로 생성하는 방식은 java9 이후로 deprecated되었다. 
  - -128 ~ 127 사이 숫자는 valueOf 사용 시 문자열 풀처럼 인스턴스 풀에서 재사용하기 때문에 효율적이다. 
### 래퍼 클래스 생성 - 박싱(boxing)
- 기본형을 래퍼 클래스로 변경하는 방식을 박싱이라고 한다. 
### intValue() - 언박싱(unboxing)
- 래퍼 클래스에 들어있는 기본형 값을 다시 꺼내는 메서드이다. 

### parseInt() vs valueOf()
- parseInt는 기본형을 반환한다. 
- valueOf는 래퍼 타입을 반환한다. 

### 오토 박싱(Autoboxing)/언박싱
- 기본형 - 래퍼 클래스 간 변환을 편리하게 하기 위해 오토박싱, 오토언박싱을 지원한다. 
- 기본형과 래퍼 클래스 변환 시 그냥 대입 연산자를 통해 변환할 수 있다. 컴파일 단계에서 바이트코드 박싱, 언박싱 코드를 추가한다.

### 래퍼 클래스와 성능
- 기본형은 래퍼 클래스에 비해 연산 시간과 메모리가 효율적이다. 
- 연산 시간과 메모리가 아주 중요하고 연산이 많이 이루어져야 하는 경우가 아니라면 래퍼 클래스를 사용하자. 

## Class 클래스
- 주요 기능
  - 타입 정보
  - 리플렉션
  - 동적 로딩과 생성
  - 어노테이션 처리

## System 클래스
- 주요 기능
  - 표준 입출력
  - 시간 측정
  - 환경 변수
  - 시스템 속성
  - 시스템 종료
  - 배열 고속 복사

## Math, Random 클래스
- Random 클래스에 동일한 seed값을 사용하면 항상 같은 값이 나온다. 

# 섹션 6: 열거형 - ENUM
- 타입(분류) 사용 시 String을 사용하면 존재하지 않는 분류, 오타, 소문자 처리 등 타입 안정성이 부족한 문제가 있다. 이런 문제를 컴파일 시간에 알 수 없다. 
- 이런 문제를 해결하기 위해 특정 범위로 값을 제한하는 것이 필요하다. 
- 문자열 상수를 사용하면 오타를 컴파일 오류로 탐지할 수는 있지만, 입력값 자체를 제한할 수는 없다. 즉 문자열 상수 대신 문자열 리터럴을 사용해도 오류가 나지 않는다. 여전히 타입 안정성이 부족하다. 

## 타입 안전 열거형 패턴(Type-Safe Enum Pattern)
- ENUM을 사용하면 나열한 항목만 사용할 수 있다. 즉 타입 안전성을 보장할 수 있다. 
- 장점
  - 타입 안전성 향상: 잘못된 값이 사용되는 것을 컴파일 시간에 알 수 있다. 
  - 데이터 일관성: 사전에 정의된 몇 개의 인스턴스만 생성하고 외부에서는 이 인스턴스들만 사용하도록 한다.
- 단점
  - 많은 코드를 작성해야 한다. 
  - 생성자를 private으로 설정하는 등 유의해야 한다. 

## 열거형 - Enum Type
- 타입 안전 열거형 패턴을 더 쉽게 사용할 수 있도록 Enum 타입을 제공한다. 
- 열거형은 강제로 Enum 클래스를 상속받는다. 따라서 다른 클래스를 상속받을 수 없다. 
- switch문에도 사용할 수 있다. 
- 인터페이스를 구현할 수 있다. 
- 열거형에 추상 메서드를 선언하고 구현할 수 있다. 
- `Enum 클래스.valueOf()` 로 Enum 타입으로의 변환이 가능하다.

# 섹션 7: 날짜와 시간
### 기본 날짜와 시간 - LocalDateTime
- 현재 지역의 시간을 다루기 위해 LocalDate, LocalTime, LocalDateTime 등의 클래스가 존재한다. 
- 현재 시간, 특정 시간 지정, 날짜/시간 분리, 합체, 계산, 비교 등의 메서드가 있다.  

### 타임존 - ZonedDateTime

### 기계 시간 - Instant
- UTC 기준 1970년 1월 1일 0시 0분 0초 이후로 경과한 시간을 의미한다. 
  - Epoch 시간(Unix timestamp): Instant를 초 단위로 표현한 시간이다. 
- 장점
  - 시간대 독립성: 지역 독립적이다. 
  - 고정된 기준점: 시간 시작 기준점이 정해져 있다. 
- 단점
  - 사용자 친화적이지 않다. 
  - 시간대 정보가 포함되지 않아 특정 지역 시간으로 변환하려면 추가 작업이 필요하다. 

### 기간, 시간의 간격 - Duration, Period
- 특정 시점의 시간(간격)
  - Period: 두 날짜 사이의 간격을 년, 월, 일로 나타냄
  - Duration: 두 시간 사이의 간격을 시, 분, 초, 나노초로 나타냄


# 섹션 8: 중첩 클래스, 내부 클래스 1
- 중첩 클래스(Nested Class)는 클래스 안에 클래스를 중첩해서 정의한 것이다. 
- 크게 not-static, static으로 구분할 수 있다. 
- non-static 중첩 클래스(내부 클래스)
  - 내부 클래스(Inner Class) -> 인스턴스 변수와 같은 위치에 선언
  - 지역 클래스(Local Class) -> 지역 변수와 같이 코드 블럭 안에서 클래스 정의
  - 익명 클래스(Anonymous Class) -> 지역 클래스의 특별한 버전
- static 중첩 클래스 -> 정적 변수와 같은 위치에 선언, static 키워드

### 중첩 vs 내부
- 중첩(Nested): 어떤 다른 것이 내부에 위치하거나 포함되는 구조적인 관계
- 내부(Inner): 나의 내부에 있는 나를 구성하는 요소
- 정적 중첩 클래스는 바깥 클래스와 전혀 다른 클래스이고 **바깥 클래스의 인스턴스에 포함되지 않는다.** 
- 내부 클래스는 바깥 클래스를 구성하는 요소이고 **바깥 클래스의 인스턴스에 소속된다.** 

- 중첩 클래스는 특정 클래스가 다른 하나의 클래스 안에서만 사용되거나, 둘이 아주 긴밀하게 연결되어 있는 경우에만 사용한다. 여러 클래스가 특정 중첩 클래스를 사용한다면 중첩 클래스로 만들면 안된다. 
- 중첩 클래스를 사용하는 이유
  - 논리적 그룹화: 특정 클래스를 다른 하나의 클래스 안에서만 사용하는 경우 중첩 클래스로 만드는 것이 논리적으로 더 그룹화된다. 
  - 캡슐화: 중첩 클래스는 바깥 클래스의 private 멤버에 접근이 가능하기 때문에 더 긴밀하게 연결되고, 불필요한 public 메서드를 제거할 수 있다. 

## 정적 중첩 클래스
- static이 붙는다. 
- 바깥 클래스의 인스턴스 멤버에는 접근할 수 없다.
- 바깥 클래스의 클래스 멤버(static)에는 접근할 수 있다(중첩 클래스가 아니어도 접근 가능하다). 
  - 정적 중첩 클래스와 일반 클래스의 유일한 차이는 private 클래스 멤버에 접근 가능한지 여부이다. 
- 접근
  - 내 클래스에 포함된 중첩 클래스가 아니라 다른 곳에 있는 중첩 클래스에 접근할 때는 `바깥 클래스.중첩 클래스`로 접근한다.
    - 이 경우 바깥 클래스 외부에서 중첩 클래스를 사용한다는 의미이므로 중첩 클래스로 만들지 않는 것이 더 낫다. 

## 내부 클래스
- static이 붙지 않는다(인스턴스 멤버가 된다). 
- 바깥 클래스의 인스턴스 멤버에 접근할 수 있다.
- 바깥 클래스의 클래스 멤버에 접근할 수 있다.
- 접근
  - 내부 클래스는 바깥 클래스 인스턴스의 일부(소속)이기 때문에, 바깥 클래스의 인스턴스 정보를 알아야 생성될 수 있다. 
  - 내부 클래스는 `new 바깥 클래스의 인스턴스 참조값.내부 클래스()`로 생성한다.
    - **내부 클래스는 바깥 클래스의 인스턴스에 소속되어야 하기 때문에 어떤 (바깥 클래스의) 인스턴스에 포함되는지를 알아야 한다.** 
    - 즉 바깥 클래스의 인스턴스 참조값이 필요하다. 
    - **바깥 클래스의 인스턴스를 먼저 생성해야 내부 클래스의 인스턴스를 생성할 수 있다.** 내부 클래스 인스턴스를 단독으로 생성할 수 없다. 

### 정리
- 정적 중첩 클래스와 다르게 **내부 클래스는 바깥 인스턴스에 소속된다.**  
- 중첩은 내 안에 있지만 내 것이 아님을 말한다. 
- 내부는 내 안에서 나를 구성하는 요소임을 말한다. 

### 같은 이름의 변수 접근
- 가까운 변수가 먼 변수를 가려서 보이지 않게 하는 것을 셰도잉(Shadowing)이라고 한다. 
- 내부 클래스에서 외부 클래스의 동명변수에 접근하려면 `바깥 클래스.this.변수명`으로 접근한다.

## 지역 클래스
- 내부 클래스의 특별한 종류이다. 
- 지역 변수와 같이 코드 블럭 안에서 정의된다. 
- 자신이 속한 코드 블럭의 지역 변수에 접근할 수 있다. 
- 자신이 속한 코드 블럭의 파라미터에 접근할 수 있다(파라미터도 지역 변수의 일종).
- 바깥 클래스의 인스턴스 멤버에 접근할 수 있다. 
- 지역 클래스는 지역 변수처럼 접근 제어자를 사용할 수 없다. 

## 지역 클래스 - 지역 변수 캡처
**지역 클래스가 접근하는 지역 변수의 값은 변경하면 안 된다.** 
- 지역 클래스를 통해 생성한 인스턴스가 자신이 속한 코드 블럭이 모두 종료된 후(현재 지역 변수가 스택 프레임에서 제거된 이후) 지역 변수에 접근하는 경우
### 지역 변수 캡처
- 변수 캡처(Capture): 자바는 위 문제를 해결하기 위해 지역 클래스의 인스턴스를 생성하는 시점에 필요한 지역 변수(지역 클래스에서 사용하는 지역 변수)를 복사해서 생성한 인스턴스에 함께 넣어둔다. 
1. 지역 클래스의 인스턴스 생성 시 지역 클래스가 접근하는 지역 변수 확인
2. 해당 지역 변수를 복사
3. 복사한 지역 변수를 힙 메모리의 인스턴스에 추가
4. 인스턴스 생성 완료
- 지역 변수가 제거된 이후 지역 변수에 접근하는 경우에는 지역 변수에 접근하는 것이 아니라 인스턴스에 캡처해 두었던 변수에 접근
  - 실제 지역 인스턴스.getClass().getDeclaredFields()에는 사용되는 지역 변수(파라미터 포함)이 들어있다.
**지역 클래스가 접근하는 지역 변수의 값은 변경하면 안 된다.**
- 변경 시 컴파일 오류가 발생한다. 즉 해당 변수들은 final이라고 생각해야 한다.
- 캡처 이후 지역 변수의 값을 변경하면 인스턴스의 캡처된 값과 실제 지역 변수의 값이 달라진다. 
- **지역변수 변경 시 캡처를 다시 할 수 없는 이유**
  - 지역변수 값 변경 시 인스턴스 캡처 값도 변경해야 함
  - 인스턴스 캡처 값 변경 시 지역변수 값도 변경해야 함
  - 개발자 입장에서 예상치 못한 곳에서 값이 변경될 수 있음
  - 지역변수 값과 인스턴스 캡처 값 간 동기화가 멀티스레드 상황에서 매우 어려움, 성능상 나쁜 영향

## 익명 클래스(Anonymous Class)
- 지역 클래스의 특별한 종류 중 하나이다. 
- 클래스 이름을 생략하고 선언과 생성을 한번에 처리할 수 있다. 
### new 클래스() {body}
- 익명 클래스는 클래스의 본문(body)을 정의하며 동시에 인스턴스를 생성한다. 
- new 다음에 바로 상속받으며 구현할 부모 타입을 입력한다. 
- 부모를 상속하면서 바로 생성한다. 

### 특징
- 이름 없는 지역 클래스를 선언하며 동시에 생성한다. 
- 부모 클래스를 상속받거나 인터페이스를 구현해야 한다. 즉 상위 클래스나 인터페이스가 필요하다. 
- 이름을 가지지 않으므로 생성자를 가질 수 없다. 기본 생성자만 사용된다. 

### 장점
- 일회성으로 사용되는 경우 클래스 별도 정의 없이 즉석 구현이 가능하다.


# 섹션 9: 중첩 클래스, 내부 클래스 2


# 섹션 10: 예외 처리1 - 이론
### 예외 처리가 필요한 이유
- 오류 상황이 발생했을 때 매번 if-else로 해결하면 코드 복잡도가 너무 크게 증가한다. 
- 정상 흐름과 오류 흐름이 섞여 한눈에 구분/파악할 수 없다. 가독성이 떨어진다.

## 예외 계층
- 자바는 프로그램 중 발생할 수 있는 예상치 못한 상황(Exception)을 처리하기 위한 매커니즘을 제공한다. 
- 자바 예외 처리는 `try`, `catch`, `finally`, `throw`, `throws` 키워드를 사용한다. 
- 예외 처리용 객체 계층
  - `Object`: 예외도 객체이다. 
  - `Throwable`: 최상위 예외 객체이다. `Exception`, `Error를` 가진다. 
    - `Error`: 메모리 부족, 심각한 시스템 오류 등 애플리케이션에서 복구 불가능한 시스템 예외이다. 개발자가 해결할 수 없고 이 예외를 잡으려고 하면 안 된다. 
    - `Exception`: 체크 예외, 애플리케이션 로직에서 사용할 수 있는 실질적 최상위 예외이다. `Exception과` 그 하위 예외(`RuntimeException` 제외)는 모두 컴파일러가 체크하는 체크 예외이다.
      - `RuntimeException`: 언체크 예외, 런타임 예외, 컴파일러가 체크하지 않는 언체크 예외이다. `RuntimeException과` 그 하위 예외는 모두 언체크 예외이다. 
      - 체크 예외: 발생한 예외를 개발자가 명시적으로 처리하지 않으면 컴파일 오류가 발생하는 예외이다. 
- catch: 상위 예외를 잡으면 그 하위 예외 모두 잡을 수 있다. `Throwable`을 잡으면 `Error`또한 잡을 수 있기 때문에 `Throwable`는 잡으면 안 된다.

### 예외 처리 기본 규칙
1. 예외가 발생하면 잡아서 처리하거나 처리할 수 없으면 밖으로 던져야 한다. 
2. 예외를 잡거나 던질 때 지정한 예외와 그 하위 예외까지 함께 처리할 수 있다.
- main() 밖으로 예외를 던지면 예외 로그를 출력하면서 시스템이 종료된다. 
- try-catch문을 사용해 예외를 잡는다. 

## 체크 예외
- 체크 예외는 잡아서 처리하거나 밖으로 던지도록 해야 한다. 그렇지 않으면 컴파일 오류가 발생한다. 
- Exception을 상속받은 예외는 체크 예외가 된다.
- 장점
  - 개발자가 실수로 예외를 누락하지 않도록 컴파일 오류를 사용한다. 어떤 체크 예외가 발생하는지 바로 알 수 있다. 
- 단점
  - 실제로는 개발자가 모든 체크 예외를 잡거나 던지도록 처리해야 하기 때문에 번거롭고 코드 양이 증가한다. 

### throw
- `throw new 예외`는 새로운 예외를 발생시킬 때 사용한다. 

### throws
- `throws 예외`는 발생시킨 예외를 메서드 밖으로 던질 때 사용한다.

## 언체크 예외
- RuntimeException과 그 하위 예외를 의미한다. 
- 컴파일러가 예외를 체크하지 않는다. 
- 예외를 던지는 throws를 생략할 수 있고 자동으로 예외를 던진다. **컴파일러가 이런 부분을 확인하지 않기 때문에 언체크 예외라고 한다.** 
  - 중요한 예외인 경우 throws를 작성해 가독성을 높일 수 있다. 
- RuntimeException을 상속받은 예외는 언체크 예외가 된다.
- 장점
  - 신경쓰고 싶지 않은 언체크 예외를 무시할 수 있다. 
- 단점
  - 개발자가 실수로 예외를 누락할 수 있다. 

### 정리
**- 체크 예외와 언체크 예외의 차이는 예외를 처리할 수 없을 때 예외를 밖으로 던지는 부분이 필수인지 여부에 있다.** 

# 섹션 11: 예외 처리2 - 실습 
### finally
- try-catch에서 catch로 잡지 못하는 예외의 경우 정상 흐름대로 작동하도록 할 수 없다.
- 자바는 try문을 시작하기만 하면 어떤 경우라도 반드시 호출되는 finally 기능을 제공한다.
- 주로 try에서 사용한 자원을 해제할 때 사용한다. 
- catch 없이 try-finally만 사용할 수도 있다. 

## 예외 계층
- 예외를 계층화해서 다양하게 만들면 더 세밀하게 예외를 처리할 수 있다. 
- catch문 작성 순서에 따라 처리가 달라진다. 하위 계층 예외를 상위 계층 예외보다 나중에 처리하면 컴파일 오류가 난다.  

## 실무 예외 처리 방안
### 처리할 수 없는 예외
- 시스템 오류 때문에 발생한 예외는 잡아도 해결할 수 있는 것이 없다. 고객에게 오류 메시지를 보여주고 내부 개발자가 문제 상황을 빠르게 보여줄 수 있도록 오류에 대한 로그를 남겨두어야 한다. 
### 체크 예외의 부담
- 애플리케이션의 모든 체크 예외를 발생하는 모든 계층에서 처리하려면 코드의 양이 엄청나게 많아지게 된다. 
- 그렇다고 throw Exception을 하면 모든 체크 예외를 다 던지게 되는데, 이러면 다른 체크 예외를 체크하는 기능이 무효화된다. 즉 컴파일러가 중요한 체크 예외가 발생해도 문제가 없다고 생각해 전부 놓치게 된다. 
- 개발자가 해결할 수 있는 예외만 잡아서 처리하고, 본인이 해결할 수 없는 예외는 신경쓰지 않는 것이 나을 수 있다. 

### try-with-resources
- try 이후 외부 자원을 반납하는 패턴이 반복되면서(try-catch-finally{자원 회수}) try-with-resources가 도입되었다. 
- try에서 자원을 사용하고 try가 끝나면 반드시 종료해서 자원을 반납한다. 
- AutoCloseable 인터페이스를 구현해야 사용할 수 있다. 
- try문을 나가는 순간(try문이 종료되거나 예외 발생 시)자원을 반납한 뒤 catch문으로 넘어간다. 
- 장점
  - 리소스 누수 방지: 모든 리소스가 제대로 닫히도록 보장한다.
  - 코드 간결성 및 가독성 향상: 명시적으로 close()를 호출하지 않아 코드가 더 간결하고 읽기 쉬워진다.
  - 스코프 범위 한정: 리소스 변수의 스코프가 try 블럭 안으로 한정된다. 
  - 조금 더 빠른 자원 해제: try -> catch -> finally -> 자원 해제 순이었는데 try -> 자원 해제로 빠른 리소스 반환이 가능하다. 