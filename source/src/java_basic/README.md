# 목차
- 2: [클래스와 데이터](https://github.com/nahowo/java-start/tree/main/source/src/java_basic#%EC%84%B9%EC%85%98-1-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0)
- 3: [기본형과 참조형](https://github.com/nahowo/java-start/tree/main/source/src/java_basic#%EC%84%B9%EC%85%98-3-%EA%B8%B0%EB%B3%B8%ED%98%95-vs-%EC%B0%B8%EC%A1%B0%ED%98%95)
- 4: [객체 지향 프로그래밍](https://github.com/nahowo/java-start/tree/main/source/src/java_basic#%EC%84%B9%EC%85%98-4-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
- 5: [생성자](https://github.com/nahowo/java-lecture/blob/main/source/src/java_basic/README.md#%EC%84%B9%EC%85%98-5-%EC%83%9D%EC%84%B1%EC%9E%90)
- 6: [패키지](https://github.com/nahowo/java-lecture/blob/main/source/src/java_basic/README.md#%EC%84%B9%EC%85%98-6-%ED%8C%A8%ED%82%A4%EC%A7%80)
- 7: [접근 제어자](https://github.com/nahowo/java-lecture/blob/main/source/src/java_basic/README.md#%EC%84%B9%EC%85%98-7-%EC%A0%91%EA%B7%BC-%EC%A0%9C%EC%96%B4%EC%9E%90)
- 8: [자바 메모리 구조와 static](https://github.com/nahowo/java-lecture/blob/main/source/src/java_basic/README.md#%EC%84%B9%EC%85%98-8-%EC%9E%90%EB%B0%94-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0%EC%99%80-static)
- 9: [final](https://github.com/nahowo/java-lecture/blob/main/source/src/java_basic/README.md#%EC%84%B9%EC%85%98-9-final)
- 10: [상속](https://github.com/nahowo/java-lecture/blob/main/source/src/java_basic/README.md#%EC%84%B9%EC%85%98-10-%EC%83%81%EC%86%8D)
- 11: [다형성1](https://github.com/nahowo/java-lecture/blob/main/source/src/java_basic/README.md#%EC%84%B9%EC%85%98-11-%EB%8B%A4%ED%98%95%EC%84%B11)
- 12: [다형성2](https://github.com/nahowo/java-lecture/blob/main/source/src/java_basic/README.md#%EC%84%B9%EC%85%98-12-%EB%8B%A4%ED%98%95%EC%84%B12)
- 13: [다형성과 설계](https://github.com/nahowo/java-lecture/blob/main/source/src/java_basic/README.md#%EC%84%B9%EC%85%98-13-%EB%8B%A4%ED%98%95%EC%84%B1%EA%B3%BC-%EC%84%A4%EA%B3%84)

# 섹션 2: 클래스와 데이터
### 클래스가 필요한 이유
- 배열 사용의 한계: 데이터 타입별 배열을 생성해야 한다. 원소의 변경이 일어날 때 관리하기 매우 어렵다. 
- 사람이 관리하기 좋은 방식은 특정 개념을 하나로 묶는 것, 개념에 해당하는 데이터를 한번에 관리하는 것

### 클래스 도입
- `class` 키워드를 사용해 클래스를 정의할 수 있다. 
- 개념을 구성하는 데이터를 클래스 내부에 변수로 정의할 수 있다. 
- `멤버 변수` 또는 `필드`: 클래스 내부에 정의한 변수
- 클래스는 관례상 대문자로 시작, 카멜케이스 사용

### 클래스와 사용자 정의 타입
- 사용자 정의 타입의 설계도가 클래스
- 설계도를 사용해 실제 메모리에 만들어진 실체가 `객체` 또는 `인스턴스`

### 실습
1. 변수 선언
    ```java
    Student student;
    ```
  - Student 타입을 담을 수 있는 변수를 생성한다. 
2. 인스턴스(객체) 생성
    ```java
    student = new Student();
    ```
  - new 키워드를 사용해 메모리에 실제 Student 인스턴스를 생성한다. 클래스의 멤버 변수가 들어갈 메모리 공간도 함께 확보한다. 
3. 참조값 보관
   - 인스턴스를 생성하면 메모리 어딘가에 있는 이 객체에 접근할 수 있는 참조값(주소)을 반환한다. 해당 참조값이 student 변수에 저장된다. 
   - 생성한 객체에 접근하기 위해 주소값을 사용한다.

### 객체 사용
- 객체의 멤버 변수에 접근하기 위해 .을 사용한다. 
- 객체에 접근하기 위해 `객체 변수.` 키워드를 사용하면 변수의 참조값을 이용해 메모리에 존재하는 객체에 접근한다.

## 클래스, 객체, 인스턴스
### 클래스 Class
- 클래스는 객체를 생성하기 위한 틀 또는 설계도이다. 객체가 가져야 할 속성과 기능을 정의한다.

### 객체 Object
- 객체는 클래스에서 정의한 속성과 기능을 가진 실체이다. 객체는 서로 독립적인 상태를 가진다. 

### 인스턴스 Instance
- 인스턴스는 특정 클래스로부터 생성된 객체를 의미한다. 객체와 인스턴스는 자주 혼용된다. 
- 인스턴스는 주로 객체가 어떤 클래스에 속해 있는지 강조할 때 사용한다. (예: A 클래스의 인스턴스)
- 모든 인스턴스는 객체이지만 그 객체가 특정 클래스로부터 생성되었다는 점을 강조하고 싶을 때 사용할 수 있다. 

# 배열
- 클래스를 원소로 가지는 배열을 생성할 수 있다.
   ```java
    Student[] students = new Student[3];
    students[0] = student1;
    students[1] = student2;
    students[2] = student3;
   ```
- 객체의 인스턴스 변수는 해당 인스턴스의 주소값을 가지기 때문에 클래스 배열의 각 원소에도 각 인스턴스의 주소값이 들어간다. 
- **자바에서의 대입은 항상 변수에 들어있는 값을 복사해서 대입한다.**
  - 변수에는 참조값이 들어가기 때문에 인스턴스 자체가 복사되는 것이 아니라 주소값이 복사된다. 

### 배열에 들어있는 객체 사용
- 배열이 가리키는 주소값(배열의 주소값) 접근 -> 배열의 원소가 가리키는 주소값(인스턴스의 주소값) 접근 -> 해당 주소값의 객체의 변수 접근


# 섹션 3: 기본형 vs 참조형
- 변수의 데이터 타입은 크게 두 가지로 구분할 수 있다. 
1. 기본형(primitive type): 변수에 사용할 값을 직접 넣을 수 있는 데이터 타입
2. 참조형(reference type): 변수에 데이터에 접근하기 위한 참조 주소를 저장하는 데이터 타입
### 기본형 vs 참조형 - 기본
- 기본형에는 실제 사용하는 값이 변수에 들어간다. 값을 바로 사용할 수 있다. 
- 참조형에는 실제 객체의 위치(주소)가 들어간다. 참조형은 객체와 배열이 있다. 
  - 객체는 .을 통해 메모리 상에 생성된 객체를 찾아가야 사용할 수 있다. 
  - 배열은 []를 통해 메모리 상에 생성된 배열을 찾아가야 사용할 수 있다. 
- 기본형은 소문자로 시작한다. int, long, char등은 기본형이다. 기본형은 개발자가 정의할 수 없다. 
- 개발자는 클래스(참조형)만 정의할 수 있다. String, Integer는 참조형이고, 개발자가 작성하는 클래스도 대문자로 시작하는 관례를 따른다.  
### 기본형 vs 참조형 - 계산
- 기본형은 값 그대로 사용할 수 있다. 
- 참조형은 참조값 그대로 사용할 수 없다. 주소지에 방문해 실제 값에 접근해야 연산을 수행할 수 있다.

### 기본형 vs 참조형 - 변수 대입
**자바에서는 변수의 값을 복사해서 대입한다.**
- 기본형 대입: 변수에 들어있는 실제 값을 복사해서 대입한다. 
- 참조형 대입: 변수에 들어있는 참조값을 복사해서 대입한다.
  - 같은 객체를 참조한다면 변수의 개수와 상관없이 실제 메모리상의 객체는 하나로 유지된다.

### 기본형 vs 참조형 - 메서드 호출
- 메서드 호출도 대입과 동일하다. 메서드 호출 시 사용하는 매개변수(파라미터)도 변수이다. 메서드를 호출할 때 매개변수에 값을 전달하는 것도 설명한 내용과 같이 값을 복사해서 사용한다.
- 기본형의 경우 매개변수로 값을 전달할 때에도 현재 변수의 값을 복사해서 사용한다. 메서드 내에서 변수의 값을 변경시켜도 다른 값을 사용하므로 호출자의 값은 변경되지 않는다. 
- 참조형의 경우 주소값을 복사해서 전달하기 때문에 같은 객체에 접근한다. 메서드 내에서 변수의 값을 변경시킨다면 호출자의 객체도 같은 주소를 가리키므로 변경이 적용된다. 

## 변수와 초기화
- 멤버 변수: 클래스 내부에서 사용되는 변수
- 지역 변수: 메서드에 선언되는 변수, 매개변수도 지역 변수에 포함
### 변수의 값 초기화
- 멤버 변수: 자동 초기화
  - 인스턴스의 멤버 변수는 인스턴스를 생성할 때 변수형의 기본값으로 초기화된다. 
  - 개발자가 초기값을 지정할 수 있다. 
- 지역 변수: 수동 초기화
  - 항상 직접 초기화해야 한다.

### null
- 참조형 변수에는 아직 가리키는 대상이 없을 때 null값이 들어간다. 
### GC
- 어떤 변수도 참조하지 않는 인스턴스는 해당 주소를 다시 구할 방법이 없다. 따라서 해당 인스턴스에 접근할 방법이 없고, 메모리 용량만 차지하게 된다. 
- 이런 인스턴스를 메모리에서 제거하기 위해 가비지 컬렉션이 사용된다. 
- 객체는 해당 객체를 참조하는 곳이 있으면 JVM이 종료될 때까지 생존한다. 중간에 어떤 객체를 참조하는 변수가 없어지면 해당 객체를 GC가 메모리에서 제거한다.

### NullPointerException
- 참조값 없이 객체를 찾아가면 null을 가리키는(pointer) 예외가 발생한다. 
- 객체를 참조할 때 .을 사용하는데, 이때 참조값이 null이라면 NullPointerException이 발생한다.

# 섹션 4: 객체 지향 프로그래밍
- 절차 지향 프로그래밍: 절차를 지향, 실행 순서를 중요하게 생각하는 방식, "어떻게"가 중심
- 객체 지향 프로그래밍: 객체를 지향, 실세계의 사물이나 사건을 객체로 보고 그 상호작용을 중요하게 생각하는 방식, "무엇을"에 중심
- 절차 지향 프로그래밍의 한계는 데이터와 기능이 분리되어 있다는 점이다. 객체 지향을 통해 기능과 그 기능에 관련된 데이터를 묶을 수 있다.

### 클래스와 메서드
- 클래스 내부에 메서드를 정의하면 기본적으로 멤버 변수를 사용한다.

# 섹션 5: 생성자
### this
- 인스턴스 내부에서 현재 인스턴스를 접근할 때 사용한다. 
- 인스턴스의 멤버 변수와 메서드의 매개변수 이름이 같다면 더 안쪽에 위치하는 매개변수가 우선순위를 가진다. 이때 멤버 변수에 접근하기 위해 `this.{멤버 변수}`를 사용한다.
- 최근 IDE가 발전하면서 멤버 변수와 매개변수를 구분해줌, 모든 멤버 변수에 this를 추가하지 않아도 됨

### 생성자 - 도입
- 객체를 생성함과 동시에 초기값을 할당하는 경우가 많다. 
- 생성자의 이름은 클래스 이름과 같아야 한다. 
- 생성자는 반환 타입 없이 비워두어야 한다.
- 파라미터 정보 확인하는 단축키: cmd + P
### 생성자 호출
- 생성자는 인스턴스 생성 후(new 키워드 사용) 즉시 호출한다. 
  - `new 생성자명(생성자에 맞는 인수 목록)`
  - 생성자를 따로 생성하지 않으면 기본 생성자를 사용한다. 즉 기존에 객체를 생성할 때 사용했던 `new 클래스명()`도 기본 생성자를 호출한 것이다.
### 생성자 장점
- 생성 직후 필요한 작업을 한번에 처리해 코드 중복 제거
- 생성자 호출을 필수로 제약: 선언만 되고 할당이 되지 않아 아무런 정보가 없는 변수가 시스템에 등장하는 것을 막음
  - 직접 정의한 생성자가 있다면 무조건 생성자를 호출해야 함, 호출하지 않는다면 컴파일 오류가 발생 -> 즉 필수값 입력을 보장할 수 있음

## 기본 생성자
- 자바 컴파일러는 클래스에 생성자가 하나도 없다면 자동으로 아무런 작동도 하지 않는 기본 생성자를 작성한다. 
  - 생성자를 작성하지 않은 클래스를 컴파일하면 .class 파일에 기본 생성자가 작성되어 있는 것을 확인할 수 있다.  
- 하지만 클래스에 생성자가 하나라도 있다면 기본 생성자는 생성되지 않는다.

## 생성자 - 오버로딩과 this()
- 생성자도 메서드 오버로딩처럼 매개변수의 조합을 변형하여 여러 생성자를 작성할 수 있다. 
### this()
- 생성자 내부에서 자신의 생성자를 호출한다. 생성자들의 중복을 줄여준다. 
- 생성자 코드의 첫번째 줄에만 작성할 수 있다. 이외의 경우 컴파일 오류가 발생한다. 

# 섹션 6: 패키지
- 파일을 분류하기 위해 폴더/디렉토리라는 개념을 제공하는데, 자바에서는 이를 패키지로 제공한다. 
### 패키지 사용
- 패키지를 사용하는 경우 해당 클래스가 어떤 패키지에 속하는지 파일의 첫 줄에 명시해줘야 한다.
- `import`를 사용해 코드에서 패키지명을 생략하고 클래스를 사용할 수 있다. `패키지.*`을 사용하면 해당 패키지 내의 모든 클래스를 사용할 수 있다.
- 클래스 이름이 같아도 패키지를 포함한 전체 경로가 다르다면 다른 클래스로 인식한다.
- 서로 다른 경로의 같은 이름을 가지는 클래스를 한번에 사용한다면 import는 둘 중 하나만 사용할 수 있다.

## 패키지 규칙
- 패키지 이름, 위치는 실제 디렉토리 위치는 일치해야 한다. 
- 패키지 이름은 모두 소문자를 사용한다. (관례) 
- 패키지 이름의 앞 부분에는 회사의 도메인 이름을 거꾸로 사용한다. (관례)
  - 오픈소스나 라이브러리로 코드를 공유한다면 꼭 지키는 것이 좋다. 
- 패키지는 계층 구조를 이루지만 import문을 사용해야 한다는 점은 변하지 않는다.

# 섹션 7: 접근 제어자
- 자바는 접근 제어자(access midifier)를 제공한다. 접근 제어자를 사용해 해당 클래스 외부에서 특정 필드/메서드에 접근하는 것을 제어할 수 있다. 
- 객체에 특정 제한을 적용해도 외부에서 객체에 직접 접근할 수 있다면 제한 적용의 의미가 없어지게 된다. 
  - 제한을 적용하고자 하는 부분에 대한 접근을 제한하기 위해 접근 제어자가 사용된다. 
- **좋은 프로그램은 적절한 제약을 제공하는 프로그램이다.** 

## 접근 제어자의 종류
- `private`: 모든 외부 호출을 제한한다. 
- `default(package-private)`: 같은 패키지 안에서의 호출을 허용한다. 
- `protected`: 같은 패키지 안에서의 호출을 허용한다. 패키지가 다를 경우 상속 관계에서의 호출은 허용한다. 
- `public`: 모든 외부 호출을 허용한다. 

- **접근 제어자의 핵심은 속성과 기능을 외부로부터 숨기는 것이다.**
### 접근 제어자 사용 - 필드, 메서드
- 객체의 필드와 메서드에 접근할 수 있는 정도를 접근 제어자를 통해 제어할 수 있다. 
- 생성자도 접근 제어자 관점에서 메서드와 동일하다. 

### 접근 제어자 사용 - 클래스 레벨
- 클래스 레벨의 접근 제어자 규칙
  - 클래스 레벨에서는 `public`, `default`만 사용할 수 있다. 
  - public 클래스는 항상 파일명과 클래스명이 같아야 한다. 
    - 하나의 파일에 `public` 클래스는 하나만 등장할 수 있다. 
    - 하나의 파일에 `default` 클래스는 여러 개 등장할 수 있다. 

## 캡슐화
- 캡슐화(Encapsulation)는 데이터와 해당 데이터를 처리하는 메서드를 하나로 묶어 외부에서의 접근을 제한하는 것을 말한다. 
- 캡슐화를 통해 데잍의 직접적인 변경을 방지/제한할 수 있다.
- 캡슐화를 안전하게 완성할 수 있도록 해 주는 장치가 접근 제어자이다. 
1. 데이터를 숨겨라
   - 객체의 데이터는 객체가 제공하는 기능인 메서드를 통해서 접근해야 한다.
2. 기능을 숨겨라
   - 외부에서 사용하지 않고 내부에서만 사용하는 기능은 감춰야 한다. 

# 섹션 8: 자바 메모리 구조와 static
- 자바 메모리 구조는 크게 메서드 영역, 스택 영역, 힙 영역으로 나눌 수 있다. 
### 메서드 영역
- 클래스 정보(설계도)를 저장한다. 
- 프로그램 실행 시 필요한 공통 데이터를 관리한다. 
  - 클래스 정보: 클래스의 실행 코드(바이트 코드), 필드, 메서드, 생성자 등 모든 실행 코드
  - static 영역: static 변수 보관
  - 런타임 상수 풀: 프로그램 실행에 필요한 공통 리터럴 상수 보관, 프로그램을 효율적으로 관리하기 위한 상수 관리

### 스택 영역
- 실제 프로그램이 실행된다. 메서드를 실행할 때 스택이 하나씩 쌓인다. 
- 자바 실행 시 각 스레드별로 하나의 실행 스택이 생성된다. 
- 메서드 실행 시 하나의 스택 프레임이 생성되고 스택 영역에 적재된다. 
- 각 스택 프레임은 지역 변수, 중간 연산 결과, 메서드 호출 정보 등을 포함한다.
- 스택 프레임은 메서드가 종료될 때 제거된다. 스택 영역에서 스택 프레임이 모두 제거되면 프로그램을 종료한다. 

### 힙 영역
- 객체(인스턴스)와 배열을 저장한다. new 키워드를 사용해 힙 영역을 사용할 수 있다. 
  - **메서드 코드는 같은 클래스의 인스턴스끼리는 전부 동일하기 때문에 메서드 영역에 저장된다.**
  - 인스턴스를 생성하면 멤버 변수를 위한 메모리는 할당되지만 메서드에 대한 메모리 할당은 없다. 인스턴스의 메서드를 호출하면 메서드 영역에서 코드를 불러 사용한다. 
- 가비지 컬렉션이 이루어지는 주요 영역이다. 더 이상 참조되지 않는 객체가 GC에 의해 제거된다. 
  - 힙 영역 외부에서의 참조 없이 힙 영역 안에서만 인스턴스끼리 참조하는 경우에도 해당 객체에 접근할 방법이 없기 때문에 GC 대상이다. 

## static 키워드
- static 키워드는 주로 멤버 변수와 메서드에 사용된다. 
- 인스턴스끼리 변수를 공유할 때 사용한다. 
- 멤버 변수에 static 키워드를 적용하면 해당 변수에 접근할 때 `data.{변수명}`처럼 인스턴스명으로 접근할 수도 있고, `Data.{변수명}`처럼 클래스명으로 접근할 수도 있다. 
  - 인스턴스 변수로 접근하면 해당 변수가 인스턴스 변수인지 클래스 변수인지 헷갈릴 수 있기 때문에 클래스 변수로 접근하는 것을 권장한다. 
- 메서드도 static으로 설정하면 클래스 소속이 되어 인스턴스 생성 없이 메서드를 사용할 수 있다. 

### 멤버 변수의 종류
1. 인스턴스 변수: static이 붙지 않은 변수, 인스턴스에 소속
2. 클래스 변수(정적 변수): static이 붙은 변수, 클래스에 소속, 자바 프로그램을 시작할 때 (변수별)하나만 생성된다. 
- static 변수는 힙 영역이 아니라 메서드 영역에서 관리한다. 멤버 변수가 인스턴스마다 생성되는 것과 다르게 static 변수는 클래스마다 생성된다.

### 변수와 생명주기
- 지역 변수(매개변수 포함): 해당 스택 프레임과 함께 생성되고 제거된다. 
- 클래스 변수: 인스턴스가 생성될 때 생성되고 힙 영역에서 인스턴스가 GC에 의해 제거되기 전까지 생존한다.
- 클래스 변수: JVM이 시작될 때 생성되고 JVM이 종료될 때까지 생존한다. 

### 정적 메서드
- static 메서드 내부에서는 static 메서드나 static 변수만 사용할 수 있다.
  - 자바 프로그램 실행 시 static이 아닌 변수/메서드는 아직 생성되지 않았기 때문에 그 때 만들어지는 static 메서드에도 non-static 요소가 포함될 수 없다. 
- static 메서드는 모든 곳에서 호출이 가능하다. 
- static 메서드도 인스턴스를 통한 접근이 가능하지만 가독성 측면에서 권장하지 않는다. 

### static import
- 정적 변수/메서드 자체를 import static으로 지정하면 클래스명을 생략하고 static 변수/메서드를 사용할 수 있다.

### main method
- main() 메서드는 static 메서드이기 때문에 객체 생성 없이 실행이 가능하다. 또 main()이 static이기 때문에 static 메서드만 호출할 수 있다. 
- 생성자의 접근 제어자를 private으로 막으면 객체 생성 없이 static 요소를 사용하도록 할 수 있다. 

# 섹션 9: final
- final 키워드는 더 이상 값을 변경할 수 없도록 할 때 사용한다. 
- class, method, 변수 등에 붙을 수 있다. 
### final - 지역 변수
- 지역 변수에 final을 적용하면 최초 한 번만 값을 할당할 수 있다. 
- 매개변수에 final을 적용하면 이미 값이 할당되어 있기 때문에 메서드 내부에서 값을 할당할 수 없다. 

### final - 멤버 변수
- 멤버 변수가 final로 지정되면 무조건 생성자에서 값을 할당해야 한다. 이후에는 값 변경이 불가능하다. 
- final 멤버 변수를 선언과 동시에 할당한 경우 생성자에서 할당이 불가능하다. 
  - 어차피 동일한 값이 들어가고 이후 변경을 막는다면 static final을 사용해 데이터를 메서드 영역에 저장하도록 하면 메모리를 절약할 수 있다.

### 상수
- static final이 붙어 변하지 않는 값 변수를 상수라고 부른다.
  - 상수는 전부 대문자와 스네이크 케이스를 사용하는 것이 관례이다.
- 데이터가 변경될 문제가 없기 때문에 필드에 직접 접근해 사용한다.

### 참조 final
- 참조형 변수에 final을 적용하면 참조 대상 자체는 재할당할 수 없다. 
- 대신 참조 대상의 변수는 재할당이 가능하다. final로 적용된 것은 참조형 변수에 들어있는 참조값(주소값)만 변경할 수 없다는 뜻이다. 

# 섹션 10: 상속
- 부모 클래스의 필드와 메서드를 자식 클래스에서 재사용할 수 있도록 한다. 
- 상속을 사용하기 위해 extends 키워드를 사용한다. 
- 자바는 다중 상속을 지원하지 않기 때문에 클래스는 한 개의 클래스만 상속받을 수 있다. 대신 부모가 다른 클래스를 상속할 수는 있다(계층 구조는 허용한다).

## 상속과 메모리 구조
- A를 상속하는 B의 인스턴스를 생성하면, B의 인스턴스를 생성하는 동시에 B의 부모인 A의 인스턴스까지 포함해 생성한다.
- 즉 **상속을 사용하면 부모 클래스도 함께 포함해 인스턴스를 생성**한다.
- 메서드를 호출할 때는 호출하는 변수의 타입(클래스)를 먼저 확인하고, 그 다음 부모 타입을 확인한다.
- 즉 본인부터 시작해서 호출한 메서드를 찾을 때까지 부모(계층 전체)를 확인한다. 가장 상위 클래스에도 찾는 메서드가 없다면 컴파일 오류가 발생한다. 

## 상속과 메서드 오버라이딩
- 부모에게서 물려받은 메서드를 자식 클래스에서 재정의하는 것을 **메서드 오버라이딩(Overriding)** 이라고 한다. 
### @Override
- 현재 메서드가 상위 메서드의 메서드를 오버라이딩하는 것임을 나타낸다. 어노테이션이 없어도 동작은 똑같이 작동하지만 부모와 메서드 형식이 다른 경우 이를 컴파일 오류로 잡아주기 때문에 사용하는 것이 좋다. 
### 오버로딩과 오버라이딩
- 오버로딩: 직역하면 과적, 메서드 이름이 같고 매개변수가 다른 메서드를 여러 개 정의하는 것
- 오버라이딩(메서드 재정의): 하위 클래스에서 상위 클래스의 메서드를 재정의하는 것

### 메서드 오버라이딩 조건
- 매서드 이름이 같아야 한다. 
- 매서드 매개변수 타입, 순서, 개수가 같아야 한다. 
- 반환 타입이 같아야 한다. 
- 접근 제어자는 상위 클래스의 메서드보다 덜 제한적이어야 한다. 
  - 상위 클래스가 protected라면 하위 클래스에서는 public, protected 제어자만 사용할 수 있다. 
- 예외는 상위 클래스보다 더 적거나 같은 수의 예외, 하위 타입의 예외만 선언할 수 있다. 
- static, final, private 키워드가 붙은 메서드는 오버라이딩이 불가능하다. 
  - `static`: 클래스 레벨에서 작동하기 때문에 인스턴스 레벨에서 사용하는 오버라이딩의 의미가 없다. 
  - `final`: final로 이미 할당된 메서드를 오버라이딩으로 재정의할 수 없다.
  - `private`: 상위 클래스에서만 접근이 가능하기 때문에 하위 클래스에서 볼 수 없다. 
- 생성자는 오버라이딩할 수 없다. 

## 상속과 접근 제어
- `protected`: default와 동일하게 패키지 내에서의 접근을 허용한다. 패키지가 달라도 상속 관계에서의 호출은 허용한다.

## super - 부모 참조
- 부모와 자식의 필드명이 같거나 메서드 오버라이딩이 되어있다면 자식에서 부모의 요소를 호출할 수 없다. 이 때 `super` 키워드를 사용한다. 

## super - 생성자
- 상속 관계의 인스턴스를 생성하면 메모리 내부에는 부모 클래스도 같이 만들어진다. 따라서 각각의 생성자도 모두 호출되어야 한다. 
- **하위 클래스의 생성자 메서드의 첫 줄에 상위 클래스의 생성자를 호출해야 한다.** 이렇게 초기화가 최상위 클래스부터 최하위 클래스 순서로 이루어진다. 
  - 생성자 첫 줄에 this()를 사용하는 경우는 예외로 한다. 
- 기본 생성자가 있다면 부모 생성자 호출을 생략할 수 있다. 


# 섹션 11: 다형성1
# 섹션 12: 다형성2
# 섹션 13: 다형성과 설계