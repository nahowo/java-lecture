# 목차
- 2: [제네릭 1](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-2-%EC%A0%9C%EB%84%A4%EB%A6%AD-1)
- 3: [제네릭 2](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-3-%EC%A0%9C%EB%84%A4%EB%A6%AD-2)
- 4: [컬렉션 프레임워크 - ArrayList](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-4-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---arraylist)
- 5: [컬렉션 프레임워크 - LinkedList](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-5-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---linkedlist)
- 6: [컬렉션 프레임워크 - List](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-6-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---list)
- 7: [컬렉션 프레임워크 - Hash](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-7-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---hash)
- 8: [컬렉션 프레임워크 - HashSet](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-8-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---hashset)
- 9: [컬렉션 프레임워크 - Set](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-9-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---set)
- 10: [컬렉션 프레임워크 - Map, Stack, Queue](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-10-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---map-stack-queue)
- 11: [컬렉션 프레임워크 - 순회, 정렬](https://github.com/nahowo/java-lecture/tree/main/source/src/java_mid2#%EC%84%B9%EC%85%98-11-%EC%BB%AC%EB%A0%89%EC%85%98-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC---%EC%88%9C%ED%9A%8C-%EC%A0%95%EB%A0%AC)

# 섹션 2: 제네릭 1
- 변수 하나로 합치기: control + T에서 8 선택
- 변수명 변경: shift + F6(fn + 터치패드)
### Object의 문제점
- 다운캐스팅이 필수적: 자식 타입은 부모 타입을 담을 수 없기 때문에 Object 객체를 반환 시 다운캐스팅을 통해 원하는 타입으로 변경해야 한다. 
- 잘못된 타입의 인수 전달: setter로 기존 타입이 아닌 다른 타입을 전달 시 컴파일 오류로 확인할 수 없고 런타임 오류가 발생한다. 즉 타입 안정성이 낮다. 
- 중복을 제거하면 타입 안정성이 낮아지고, 타입 안정성을 높이면 코드 재사용성이 낮아진다. 

## 제네릭
- 제네릭의 영어 의미는 일반적인, 범용적인이다.  
- `<>`(다이이몬드)를 사용한 클래스를 제네릭 클래스라고 한다.
- 클래스명 오른쪽에 `<T>` 처럼 선언하면 제네릭 클래스가 된다. T는 타입 매개변수라고 하며, 매개변수이므로 T 말고 다른 이름을 사용해도 된다. 
  - 타입 매개변수는 일반적으로 대문자를 사용하고 용도에 맞는 단어의 첫글자를 사용하는 관례를 따른다.
- T 타입은 이후에 다른 타입으로 변할 수 있다. 
- 인스턴스 생성 시점에 T의 타입(참조형만 가능)을 지정한다. 이후 클래스의 T가 모두 해당 타입으로 변한다. 설정한 타입과 맞지 않으면 컴파일 오류가 발생한다. 즉 타입 안정성을 보장하기 때문에 캐스팅도 필요하지 않다. 
  - 컴파일러가 입력한 타입 정보를 기반으로 컴파일 과정에서 반영한다(실제 해당 타입의 코드가 생성되는 것은 아니다). 
- 제네릭을 사용해 중복 제거와 타입 안정성을 모두 확보할 수 있다. 

### 타입 추론
- 인스턴스 생성 시 `GenericClass<Integer> genericClass = new GenericClass<>()` 처럼 다이아몬드 안에 타입을 생략할 수 있다.
- 타입 추론은 자바 컴파일러가 타입을 추론할 수 있는 상황에서만 가능하다. 즉 주변에 읽을 수 있는 타입 정보가 있어야 추론할 수 있다. 

### 제네릭 용어
- 제네릭의 핵심은 사용할 타입을 미리 정의하지 않는다는 점이다. 메서드 매개변수와 인자의 관계와 비슷하다. 
- 메서드 매개변수와 인자
  - 매개변수(parameter): 중간에서 연결(매개)해주는 변수, 인자를 받아서 처리해줌
  - 인자, 인수(argument): 실제 메서드로 전달되는 값
- **실행 시점에 메서드의 매개변수에 인자를 전달해서 메서드의 사용할 값을 결정한다.**
- 제네릭의 타입 매개변수와 타입 인자
  - 제네릭 클래스 정의 시 내부에서 사용할 타입을 미리 결정하는 것이 아니라, **해당 클래스를 실제 사용하는 생성 시점에 내부에서 사용할 타입을 결정한다.**
- 매서드는 **매개변수**에 **인자**를 전달해서 사용할 값을 결정한다. 
- 제네릭 클래스는 **타입 매개변수**에 **타입 인자**를 전달해서 사용할 타입을 결정한다.
- 제네릭 타입 사용 시 다이아몬드 없이 타입 지정을 생략하면 타입 인자가 Object로 들어간다. 이런 경우를 원시 타입(Row Type)이라고 한다.
  - 제네릭이 없던 과거 코드와의 호환성을 위해 원시 타입을 지원한다. 원시 타입은 위에서 나왔던 타입 안정성 문제 때문에 지양해야 한다.  
- 오버라이딩 단축키: control + O

# 섹션 3: 제네릭 2
## 제네릭의 문제
- 메서드 정의 시점에서는 T의 타입을 알 수 없다. 즉 T에 어떤 타입 인자가 들어올지 모르기 때문에 모든 객체에서 사용 가능한 Object의 메서드만 사용 가능하다.
- T의 타입 인자로 어떤 타입이든 들어올 수 있다.

### 타입 매개변수 제한
- 제네릭 클래스와 관련있는 타입만 타입 인자로 들어오도록 제한할 수 있다. 즉 타입 매개변수를 제한할 수 있다. 
- 타입의 상한을 지정해서 그 외의 타입 인자가 들어오는 것을 컴파일 시점에 막는다. 지정한 상한 타입의 메서드를 제네릭 클래스에서 사용할 수 있다. 

## 제네릭 메서드
- 제네릭 메서드는 클래스 전체가 아니라 특정 메서드 단위로 제네릭을 도입할 때 사용한다. 
- 제네릭 메서드를 정의할 때는 메서드의 반환 타입 왼쪽에 다이아몬드를 사용해 타입 매개변수를 적는다. 
  - `GenericMethod.<Integer>genericMethod(i)`
- 메서드를 실제 호출하는 시점에 다이아몬드를 사용해서 타입을 정하고 호출한다.

### 인스턴스 메서드, static 메서드
- 제네릭 메서드는 인스턴스 메서드와 static 메서드에 모두 적용할 수 있다. 
- 제네릭 타입은 static 메서드에 타입 매개변수를 사용할 수 없다. 제네릭 타입은 객체 생성 시점에 타입이 정해지는데, static 메서드는 인스턴스 단위가 아니라 클래스 단위로 작동하기 때문에 제네릭 타입과 무관하다. 
- 따라서 static 메서드에 제네릭 타입을 도입하려면 제네릭 메서드를 사용해야 한다. 
- 타입 매개변수 제한
  - 제네릭 메서드도 제네릭 타입과 마찬가지로 타입 매개변수를 제한할 수 있다. 
- 타입 추론
  - 타입 인자를 추론할 수 있다. 제네릭 메서드에 타입을 매번 전달하는 것은 번거롭기 때문에 주로 타입 추론을 사용한다. 

### 제네릭 타입 vs 제네릭 메서드
- 클래스의 제네릭 타입보다 제네릭 메서드가 더 높은 우선순위를 가진다. 변수와 더 가깝고 구체적인 제네릭 메서드가 적용된다. 
- 모호한 경우 제네릭 이름을 다르게 변경하는 게 좋다. 

## 와일드 카드
- 컴퓨터 프로그래밍에서 와일드 카드는 하나 이상의 문자들을 상징하는 특수 문자를 의미한다.
- 와일드 카드는 제네릭 타입/제네릭 메서드를 선언하는 것이 아니라, 이미 만들어진 제네릭 타입을 활용할 때 사용한다. 
- 타입 인자가 정해진 제네릭 타입을 전달받아 활용할 때 사용한다. 
- 비제한 와일드 카드는 `<? extends Object>`를 의미한다. 모든 타입을 받을 수 있다. 
- 와일드 카드는 입력받은 타입을 그대로 사용하고 동적으로 변환하거나 타입 매개변수를 결정할 수 없다. 이런 경우에는 제네릭 메서드를 사용해야 한다.

### 상한 와일드 카드
- 와일드 카드에도 상한을 설정할 수 있다. `<? extends {클래스}>`를 이용해 {클래스} 이하 클래스를 모두 사용할 수 있다. 

### 하한 와일드 카드
- 하한을 설정할 수 있다. `<? super {클래스}>`를 이용해 {클래스} 이상 클래스를 모두 사용할 수 있다.

## 타입 이레이저
- 제네릭은 자바 컴파일 단계에서만 사용되고 컴파일 이후에는 제네릭 정보가 삭제된다. 즉 바이트코드 .class에는 타입 매개변수가 존재하지 않는다. 
- 제네릭은 개발자가 직접 캐스팅하던 코드를 컴파일러가 대신 처리해주는 방식이다. 
- 타입 이레이저를 사용하면 런타임 시점에는 제네릭 정보가 제거된 이후이기 때문에 instanceof나 생성자를 사용할 수 없다. 

# 섹션 4: 컬렉션 프레임워크 - ArrayList
## 배열
- 배열에서 인덱스를 이용하면 매우 빠르게(O(1)) 자료를 찾을 수 있다.
  - 배열은 메모리 상에서 원소 순서대로 붙어서 존재한다. 배열의 시작 위치 참조값에서 자료 크기 * 인덱스 번호를 곱하면 원하는 메모리 위치를 찾을 수 있다. 
    - `i번째 인덱스 원소의 주소 = 배열 시작 참조(배열[0]의 주소) + (자료형 크기 * i)` 
- 인덱스를 통해 입력, 변경, 조회를 O(1) 시간에 처리할 수 있다. 
- 배열의 검색
  - 배열의 각 원소값을 찾으려는 값과 비교해야 하기 때문에 O(n)의 시간이 걸린다. 
- 배열에 원소 추가
  - 데이터를 중간에 추가하면 기존 데이터가 오른쪽으로 한 칸씩 이동하기 때문에 O(n)의 시간이 걸린다.
  - 데이터를 맨 끝(오른쪽)에 추가하면 기존 데이터는 변경되지 않고 새 데이터가 들어갈 공간만 확보해서 넣으면 되기 때문에 O(1)의 시간이 걸린다.

## 리스트
- 배열의 불편함은 길이를 동적으로 변경할 수 없고, 데이터를 추가할 때 번거롭다는 점에 있다. 
- 배열의 불편함을 해결하기 위해 리스트를 사용할 수 있다. 
- 배열: 순서가 있고 중복 허용, 크기가 정적으로 고정
- 리스트: 순서가 있고 중복 허용, 크기가 동적으로 변경 가능
- 배열 리스트(ArrayList): 리스트 자료구조를 사용하지만 내부 데이터는 배열에 보관하는 것

# 섹션 5: 컬렉션 프레임워크 - LinkedList
## 노드와 연결 - 연결 리스트(Linked list)
- 배열 리스트는 크기를 동적으로 변경할 수 있지만 삽입/삭제 연산의 경우 데이터의 이동이 필요하다는 단점이 있다. 
- 노드에 next 필드를 추가하고 다음 노드의 참조값을 저장하도록 하면 필요한 만큼만 노드를 만들어서 연결하면 되기 때문에 데이터 삽입에 O(1) 시간이 걸리고 메모리도 절약할 수 있다.  
### 리스트
- 순서가 있고 중복을 허용하는 자료구조이다. 
- `배열 리스트`: 리스트의 내부에서 배열을 사용하는 리스트
- `연결 리스트`: 리스트의 내부에서 노드와 연결 구조를 사용하는 리스트
- 연결 리스트의 인덱스 접근
  - 메모리가 연속되지 않기 때문에 O(n)이 걸린다. 
- 연결 리스트의 검색
  - 모든 데이터를 확인해야 하기 때문에 O(n)이 걸린다. 
- 연결 리스트의 삽입/삭제
  - 마지막 데이터를 찾는 데에 O(n)이 걸리기 때문에 O(n)이 걸린다.
- next 정보를 저장하기 위한 추가 메모리가 사용되지만 비어 있는 원소를 저장해둘 필요가 없기 때문에 메모리가 절약된다. 
- 배열 리스트에서 삽입/삭제 시 전체 데이터를 이동시키는 과정이 필요했다. 연결 리스트에서는 실제 인덱스가 존재하지 않기 때문에 앞, 전, 현재 노드의 next 참조값만 변경해주면 삽입/삭제를 O(1)만에 수행할 수 있다. 

### 배열 리스트 vs 연결 리스트 시간복잡도
| 기능 | 배열 리스트 | 연결 리스트 |
| --- | --- | --- |
| 인덱스 조회 | O(1) | O(n) |
| 검색 | O(n) | O(n) |
| 앞에 추가/삭제 | O(n) | O(1) |
| 뒤에 추가/삭제 | O(1) | O(n) |
| 중간 추가/삭제 | O(n) | O(n) |

# 섹션 6: 컬렉션 프레임워크 - List
## 의존관계 주입(Dependency Injection; DI)
- 데이터를 앞에 추가/삭제하는 일이 많다면 연결 리스트를 사용하는 것이 효율적이다. 
- 특정 클래스가 인터페이스가 아닌 구체적인 클래스를 사용하면 이것을 구체적인 클래스에 의존한다고 표현한다(클래스를 사용하기 위해 구체적인 클래스가 필요). 
- 구체적인 클래스에 직접 의존하면 클래스를 갈아끼울 때마다 여기에 의존하던 클래스 코드도 함께 변경해야 한다. 
- 클래스 코드를 변경하지 않으려면 **구체적인 클래스가 아니라 추상적인 인터페이스에 의존할 수 있다.** 
- `의존관계 주입`: 생성자에 구체적인 클래스를 입력하도록 하여 런타임 시간으로 결정을 미룰 수 있다. 
  - 결과적으로 **클라이언트 코드를 변경하지 않으면서 원하는 전략(구체 클래스)을 런타임에 지정할 수 있다.**
  - 클라이언트 코드의 외부에서 의존관계가 결정되어 구현체가 생성자로 전달된다. 관계가 외부에서 주입되는 것 같아서 의존관계 주입이라고 부른다. 
  - 생성자를 통해 주입되었기 때문에 생성자 의존관계 주입이라고 한다. 

## 의존관계의 종류
- 의존관계는 크게 컴파일 타임 의존관계와 런타임 의존관계로 나뉜다. 

### 컴파일 타임 의존관계
- 컴파일 타임 의존관계는 자바 컴파일러가 보는 의존관계이다. 클래스에 모든 의존관계가 나타나서 바로 확인할 수 있는 관계를 의미한다. 

### 런타임 의존관계
- 런타임 의존관계는 실제 프로그램이 작동할 때 보이는 의존관계이다. 주로 생성된 인스턴스와 그것을 참조하는 의존관계이다. 
- 프로그램이 실행될 때 인스턴스간의 의존관계이다. 
- 런타임 의존관계는 프로그램 실행 동안 계속 바뀔 수 있다.

## 자바 리스트
### 컬렉션 프레임워크 - 리스트
- Collection 인터페이스: java.util 패키지의 컬렉션 프레임워크 핵심 인터페이스 중 하나이다. 데이터 그룹을 다루기 위한 메서드를 정의한다. 
### 자바 ArrayList
- 기본 CAPACITY는 10이고 초과 시 길이를 50%씩 증가시킨다.
- 메모리 고속 복사 연산을 사용해 그냥 복사보다 훨씬 빠르게 수행한다. System.arraycopy()를 사용한다. 
### 자바 LinkedList
- 이중 연결 리스트 구조이다. 마지막 노드에 대한 참조도 제공해서 끝에 추가하는 경우 O(1)이 걸린다. 역방향 조회도 가능하다.

# 섹션 7: 컬렉션 프레임워크 - Hash
## 리스트(List) vs 세트(Set)
- 리스트: 요소들의 순차적인 컬렉션이다. 
  - 순서 유지
  - 중복 허용
  - 인덱스 접근
- 세트: 유일한 요소들의 컬렉션이다. 
  - 유일성(중복 허용 X)
  - 순서 미보장(인덱스 X)
  - 빠른 검색

## 해시 알고리즘
- 데이터 값을 인덱스 자체로 이용하면 검색을 O(1) 시간에 수행할 수 있다. 
- 대신 데이터 값의 범위만큼 배열을 할당해야 하기 때문에 메모리가 낭비되는 문제가 발생한다. 

### 나머지 연산 - 해시 인덱스
- 위의 문제를 해결하기 위해 나머지 연산을 사용한다. 
- 해시 인덱스: 배열의 인덱스로 사용하기 위해 원래의 값을 계산한 인덱스
- 해시 인덱스를 사용하면 메모리 문제를 해결할 수 있다. 
### 해시 충돌
- 다른 데이터가 같은 해시 인덱스를 가지게 된다면 해시 충돌이 일어난다. 
- 해시 충돌은 낮은 확률로 일어날 것이라고 가정한 뒤, 해시 충돌이 일어났을 때 충돌이 일어난 값들을 같은 해시 인덱스에 저장한다. 
- 배열을 사용했다면 하나의 인덱스에 여러 값을 저장하는 배열/리스트 등을 사용해 여러 값을 저장할 수 있다.
- 만약 모든 값이 같은 해시 인덱스에 저장된다면 최종 시간복잡도는 O(n)이 된다. 하지만 확률적으로 해시 인덱스가 넓게 펼쳐지기 때문에 대부분의 경우에는 O(1)으로 데이터를 검색할 수 있다. 
- 해시 알고리즘에 사용되는 CAPACITY값이 너무 작다면 해시 충돌이 빈번해지고, 너무 크다면 메모리가 낭비된다. 
  - 통계적으로 입력한 데이터의 수가 배열 크기의 75%를 넘지 않으면 해시 충돌이 잘 발생하지 않는다. 

# 섹션 8: 컬렉션 프레임워크 - HashSet
# 섹션 9: 컬렉션 프레임워크 - Set
# 섹션 10: 컬렉션 프레임워크 - Map, Stack, Queue
# 섹션 11: 컬렉션 프레임워크 - 순회, 정렬