# 섹션 2: Hello World
## 3: 자바 프로그램 실행
### public class HelloJava
- HelloJava는 클래스이다. 파일명과 클래스명은 같아야 한다. 
- {} 블록으로 클래스를 구분한다. 

### public static void main(String[] args) {}
- main은 함수(메서드)이다. 클래스와 동일하게 {} 블록으로 메서드를 구분한다. 
- 자바는 main(String[] args) 메서드를 찾아서 프로그램을 시작한다. 메서드 이름이 main이더라도 매개변수가 다르면 인식하지 못한다. 
  ```plain text 
  Error: Main method not found in class HelloJava, please define the main method as:
    public static void main(String[] args)
    or a JavaFX application class must extend javafx.application.Application
- psvm으로 빠르게 main 메서드를 작성할 수 있다(intelliJ). 
- System.out.println은 값을 콘솔에 출력한다. sout을 단축키로 사용한다.  
  - soutv를 사용하면 가장 가까운 변수를 자동으로 sout에 추가한다. 
- 자바는 문자열을 사용할 때 쌍따옴표를 사용한다. 

### 주석
- //로 한 줄 주석이 가능하다. 
- /* */사이에 주석처리할 코드를 작성하면 여러 줄 주석이 가능하다.

---
## 5: 자바란?
### 자바 표준 스펙
- 자바는 **표준 스택**과 **구현**으로 나눌 수 있다.
- 자바 표준 스택: java 컴파일러 스펙, java 실행 라이브러리 스펙, JVM 스펙 등
  - 자바는 이렇게 만들어야 한다는 설계도
  - 여러 회사에서 표준 스택을 기반으로 실제 작동하는 자바를 만듦
  - 자바 표준 스펙은 자바 커뮤니티 프로세스(JCP)를 통해 관리
- 다양한 자바 구현
  - 여러 회사에서 자바 표준 스펙에 맞추어 실제 작동하는 자바 프로그램 개발
    - Amazon Correto(AWS에 최적화)
  - 각 회사들은 대부분 Windows, MAC, Linux등 다양한 OS에서 작동하는 버전의 자바도 함께 제공
  - 예시: java 컴파일러, java 실행 라이브러리, JVM 구현
    - 오라클 Open JDK
    - Adopitum Eclipse Temurin
    - Amazon Correto
- 다른 회사 제품으로 변경하더라도 대부분 문제 없이 작동
### 컴파일과 실행
1. Hello.java 같은 java 소스 코드를 개발자가 작성 
2. javac 프로그램(java 컴파일러)가 Hello.java 소스 코드를 컴파일.java -> .class 파일 생성
3. 자바 소스 코드를 바이트코드로 변환해 자바 가상 머신에서 더 빠르게 실행되도록 최적화/문법 오류 검출
4. java 프로그램으로 자바 프로그램 실행
5. JVM이 실행되며 프로그램 작동

- intelliJ를 통한 자바 컴파일/실행
  - 컴파일: intelliJ가 자동으로 javac 프로그램 실행
  - 프로젝트 디렉토리의 out 디렉토리에 컴파일된 .class파일 존재
  - 실행: 클래스 파일의 초록 삼각형을 누르면 intelliJ가 컴파일(javac)/실행(java) 둘 다 수행

### 자바와 운영체제 독립성
- 일반적 프로그램은 특정 OS가 사용하는 명령어들로 구성되기 때문에, 다른 OS에서 실행할 수 없다. 
- 자바는 자바가 설치된 모든 OS에서 실행할 수 있다. 자바가 OS 호환성 문제를 알아서 해결한다.
- 개발자가 MAC 환경에서 자바 코드를 개발하고, 컴파일한 .class 파일을 Linux 기반 서버에 배포해도 아무런 문제 없이 사용 가능하다.


# 섹션 3: 변수
### 패키지
- 자바 파일을 구분하기 위한 폴더로 이해하기
- 패키지 내부의 클래스에는 ```package {패키지명};``` 이라는 코드로 소속 패키지를 선언해야 한다.
### 변수
- 변수 선언: 값을 보관할 데이터 저장소를 만든다. 어떤 데이터가 들어갈지, 어떤 이름인지를 지정한다. 
- 변수에 값 대입: 저장소에 실제 데이터를 넣는다. 대입 연산자(=)를 사용한다.
- 자바는 runtime에 변수의 값을 읽어 사용한다. 
- 변수의 값 변경
  - static이 아닌 변수는 대입 연산자를 여러번 사용해 업데이트할 수 있다. 
### 변수 선언
- 하나씩, 여러개씩 변수를 선언할 수 있다. 
- 초기화하지 않은 변수 읽기
  ```
  java: variable c might not have been initialized
  ```
  - 변수를 초기화하지 않고 접근하면 위와 같은 컴파일 오류가 발생한다. 
  - 컴파일 오류이기 때문에 .java 파일에서 오류가 발생하고, .class 파일은 생성되지 않는다.
  - 컴퓨터에서 메모리는 여러 시스템이 함께 사용한다. 변수 선언 시 메모리상의 어떤 공간을 차지/사용하는데, 기존에 어떤 값이 있었는지 알 수 없다. 따라서 초기화를 하지 않으면 이상한 값이 출력될 수 있다. 
  - 또한 자바는 초기화되지 않은 변수(선언만 하고 초기화/사용이 없음)는 컴파일하지 않도록 최적화한다.
### 변수 타입
- int: 정수, 각 타입의 최대값을 선언하면 아래와 같다. 범위를 벗어나면 컴파일 오류가 발생한다. 
  - byte(1byte): 2^8
  - short(2byte): 2^16
  - int(4byte): 2^32
  - long(8byte): 2^64, 숫자 뒤에 L을 붙여줘야 한다(소문자 l은 1과 혼동 가능성이 있어 지양). 
    ```java
    byte b = 127;
    short s = 32767;
    int i = 2147483647;
    long l = 9223372036854775807L;

- double: 실수, 각 타입의 최대값을 선언하면 아래와 같음
  - float(4byte): 2^32, 숫자 뒤에 f를 붙여줘야 한다. 
  - float(8byte): 2^64
      ```java
    float f = 10.0f;
    double d = 10.0;
- boolean(1byte): 참/거짓
- char(1byte): 문자 하나, 따옴표(')로 감쌈
- String: 문자열, 쌍따옴표(")로 감쌈, 문자 길이에 따라 메모리도 동적으로 달라짐
### 리터럴(Literal)
- 변수를 직접 작성한 고정된 값들을 리터럴이라고 한다. 리터럴 자체는 바뀌지 않는다.
### 실무에서의 사용
- byte, short, float, char은 거의 사용하지 않는다. 메모리 용량보다 개발 속도/효율에 초점을 맞추는 게 더 효과적이다.
- 정수는 int, long을 주로 사용한다. 파일을 다룰 떄는 가끔 byte를 사용한다. 
- 실수는 무조건 double을 사용한다. 
- 조건문에서 boolean을 사용한다. 
- 문자 하나든 문자열이든 모두 String을 사용하는 게 편리하다. 
### 변수 명명 규칙
- **규칙**
  - 숫자로 시작 불가능
  - 공백 포함 불가능
  - 예약어 사용 불가능
  - 영문자, 숫자, 달러 기호, 언더바만 사용 가능
- **관례**
  - 카멜 케이스 사용
  - 클래스는 대문자로 시작, 카멜 케이스
  - 나머지는 소문자로 시작, 카멜 케이스
  - 예외
    - 상수는 전부 대문자, 스네이크 케이스 사용
    - 패키지는 모두 소문자
  - 변수명은 용도를 명확하게 설명하는 단어를 사용해야 한다.