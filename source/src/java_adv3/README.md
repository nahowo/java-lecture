# 목차
- 2: [람다가 필요한 이유](https://github.com/nahowo/java-lecture/blob/main/source/src/java_adv3/README.md#%EC%84%B9%EC%85%98-2-%EB%9E%8C%EB%8B%A4%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0)
- 3: [람다](https://github.com/nahowo/java-lecture/blob/main/source/src/java_adv3/README.md#%EC%84%B9%EC%85%98-3-%EB%9E%8C%EB%8B%A4)
- 4: [함수형 인터페이스](https://github.com/nahowo/java-lecture/blob/main/source/src/java_adv3/README.md#%EC%84%B9%EC%85%98-4-%ED%95%A8%EC%88%98%ED%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4)
- 5: [람다 활용](https://github.com/nahowo/java-lecture/blob/main/source/src/java_adv3/README.md#%EC%84%B9%EC%85%98-5-%EB%9E%8C%EB%8B%A4-%ED%99%9C%EC%9A%A9)
- 6: [람다 vs 익명 클래스](https://github.com/nahowo/java-lecture/blob/main/source/src/java_adv3/README.md#%EC%84%B9%EC%85%98-6-%EB%9E%8C%EB%8B%A4-vs-%EC%9D%B5%EB%AA%85-%ED%81%B4%EB%9E%98%EC%8A%A4)
- 7: [메서드 참조](https://github.com/nahowo/java-lecture/blob/main/source/src/java_adv3/README.md#%EC%84%B9%EC%85%98-7-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B0%B8%EC%A1%B0)
- 8: [스트림 API 1 - 기본](https://github.com/nahowo/java-lecture/blob/main/source/src/java_adv3/README.md#%EC%84%B9%EC%85%98-8-%EC%8A%A4%ED%8A%B8%EB%A6%BC-api-1---%EA%B8%B0%EB%B3%B8)
- 9: [스트림 API 2 - 기능](https://github.com/nahowo/java-lecture/blob/main/source/src/java_adv3/README.md#%EC%84%B9%EC%85%98-9-%EC%8A%A4%ED%8A%B8%EB%A6%BC-api-2---%EA%B8%B0%EB%8A%A5)
- 10: [스트림 API 3 - 컬렉터](https://github.com/nahowo/java-lecture/blob/main/source/src/java_adv3/README.md#%EC%84%B9%EC%85%98-10-%EC%8A%A4%ED%8A%B8%EB%A6%BC-api-3---%EC%BB%AC%EB%A0%89%ED%84%B0)
- 11: [Optional](https://github.com/nahowo/java-lecture/blob/main/source/src/java_adv3/README.md#%EC%84%B9%EC%85%98-11-optional)
- 12: [디폴트 메서드](https://github.com/nahowo/java-lecture/blob/main/source/src/java_adv3/README.md#%EC%84%B9%EC%85%98-12-%EB%94%94%ED%8F%B4%ED%8A%B8-%EB%A9%94%EC%84%9C%EB%93%9C)
- 13: [병렬 스트림](https://github.com/nahowo/java-lecture/blob/main/source/src/java_adv3/README.md#%EC%84%B9%EC%85%98-13-%EB%B3%91%EB%A0%AC-%EC%8A%A4%ED%8A%B8%EB%A6%BC)
- 14: [함수형 프로그래밍](https://github.com/nahowo/java-lecture/blob/main/source/src/java_adv3/README.md#%EC%84%B9%EC%85%98-14-%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)

# 섹션 2: 람다가 필요한 이유
- **프로그래밍에서 중복을 제거하고 좋은 코드를 유지하는 핵심은 변하는 부분과 변하지 않는 부분을 분리하는 것이다.**
- 값 매개변수화(Value Parameterization): 구체적인 값을 메서드 안에 두는 것이 아니라 매개변수를 통해 외부에서 전달받도록 해 메서드의 동작을 다형화하고 재사용성을 높이는 방법
  - 값을 바꿔가며 메서드의 동작을 다르게 함
- 동작 매개변수화(Behavior Parameterization): 코드 조각(동작, 로직)을 메서드 안에 두는 것이 아니라 매개변수를 통해 외부에서 전달받도록 해 메서드의 동작을 다형화하고 재사용성을 높이는 방법
  - 어떤 동작을 수행할지를 메서드에 전달
  - 동작을 수행하는 클래스를 정의하고 이를 인스턴스로 전달해야 한다는 복잡성이 존재
- 람다를 사용하면 클래스, 인스턴스를 정의하지 않고 위의 문제를 해결할 수 있다. 
### 함수 vs 메서드
- 함수(Function)와 메서드(Method)는 둘 다 어떤 작업을 수행하는 코드의 묶음이다. 하지만 일반적으로 OOP 관점에서 차이가 존재한다. 
- `함수`
  - 독맂벅으로 존재, 클래스와 직접적인 연관이 없음
  - 객체지향 언어가 아닌 C 등의 절차적 언어에서는 모든 로직이 함수 단위로 구성
  - 객체지향 언어라도 파이썬이나 js처럼 클래스 밖에서도 정의할 수 있는 함수 개념을 지원하는 경우 그냥 함수라고 함
- `메서드`
  - 클래스(또는 객체)에 속해 있는 함수
  - 객체의 상태에 직접 접근하거나 객체가 제공해야 할 기능 구현
  - 대부분의 객체지향 언어에서 클래스 내부에 정의된 함수는 보통 메서드라고 부름
- 호출 방식과 스코프
  - 함수는 호출 시 객체 인스턴스가 필요하지 않다. 지역 변수, 전역 변수와 함께 동작하며 클래스나 객체 특성(인스턴스 변수 등)은 다루지 못한다. 
  - 메서드는 `객체.메서드명` 형식으로 호출한다. 호출 시 객체의 필드나 다른 메서드에 접근 가능하고 이를 이용해 로직을 수행한다. 인스턴스 메서드, 클래스 메서드, 추상 메서드 등 다양한 형태가 있을 수 있다. 
- 함수와 메서드는 수행 역할은 같지만 소속과 호출 방식에서 차이가 있다.

# 섹션 3: 람다

## 람다
- 람다는 () -> {}로 표현한다. ()가 메서드 매개변수 부분, {} 부분에 코드 조각이 들어간다.
- 이름, 반환 타입은 생략하고 매개변수와 본문만 간단하게 작성할 수 있다. 익명 클래스를 사용하는 것보다 코드가 훨씬 간단해진다.
### 함수형 인터페이스
- 정확히 하나의 추상 메서드를 가지는 인터페이스를 의미한다.
- 람다는 함수형 인터페이스에만 할당할 수 있다.
- 단일 추상 메서드(Single Abstract Method; SAM)
- 람다는 단일 추상 메서드를 가지는 인터페이스에만 할당할 수 있다. 즉 클래스, 추상 클래스에는 할당할 수 없다. 어떤 메서드에 람다를 할당해야 하는지 모르기 때문이다.
### @FunctionalInterface
- @FunctionalInterface 어노테이션을 붙이면 해당 어노테이션이 함수형 인터페이스임을 보장할 수 있다. @Override와 동일하게 함수형 인터페이스가 아니라면 컴파일 오류가 발생한다.
### 람다와 시그니처
- 람다를 함수형 인터페이스에 할당할 떄는 `메서드 시그니처`가 일치해야 한다.
  - 메서드 이름
  - 매개변수 수와 타입, 순서
  - 반환 타입
### 람다와 생략
- 단일 표현식(하나의 값으로 평가되는 코드 조각)인 경우 return과 중괄호를 생략할 수 있다.
- 타입 추론: 함수형 인터페이스에는 하나의 메서드만 존재하고, 해당 인터페이스에 메서드 매개변수 타입이 작성되어 있기 때문에, 람다식 작성 시 매개변수 타입을 작성하지 않아도 컴파일러가 자동으로 추론해준다.
- 매개변수가 정확하게 1개인 경우 매개변수를 감싸는 괄호를 생략할 수 있다.
### 람다의 전달
- 메서드의 인자, 반환 타입으로 람다(인스턴스)를 전달할 수 있다. 타입은 함수형 인터페이스여야 한다.
### 고차 함수
- 람다를 변수에 대입하거나 람다를 매서드의 매개변수나 반환값으로 넘기는 것은 람다 인스턴스의 참조값을 대입/전달하는 것이다. 이를 통해 코드의 간결성과 유연성이 높아진다.
- `고차 함수(Higher-Order Function)`은 함수를 값처럼 다루는 함수를 뜻한다. '고차'의 의미는 함수를 다루는 추상화 수준이 높다는 데에서 유래했다.
  - 함수를 인자로 받는 함수
  - 함수를 반환하는 함수
- 위의 매개변수나 반환값에 함수를 활용하는 함수가 고차 함수에 해당한다.

# 섹션 4: 함수형 인터페이스
### 람다와 제네릭
- 람다에 제네릭을 도입하면 매개변수나 반환 타입에 대해 다형성을 제공해 중복을 제거할 수 있다. 
### 람다와 타겟 타입
- 제네릭 사용 시 중복을 제거하고 유지보수성을 높여주지만 다음 두 가지 문제가 있다. 
1. 모든 개발자들이 비슷한 함수형 인터페이스 작성
2. 다른 개발자가 작성한 함수형 인터페이스와 호환 불가능
   - 완벽하게 동일한 기능을 제공하더라도(시그니처가 동일하더라도) 인터페이스 자체가 다르면 대입할 수 없다. 
- 람다는 그 자체만으로는 구체적인 타입이 정해져 있지 않고, 타겟 타입이라고 불리는 맥락에 의해 타입이 결정된다. 
  - 대입되는 참조 변수가 어떤 함수형 인터페이스를 가리키느냐에 따라 타입이 결정된다. 
- 자바는 위 문제를 해결하기 위해 필요한 함수형 인터페이스 대부분을 기본으로 제공한다. `Function<T, R>`을 사용하자. 
## 기본 함수형 인터페이스
### Function
- 입력 O, 반환 O
### Consumer
- 입력 O, 반환 X
### Supplier
- 입력 X, 반환 O
### Runnable
- 입력 X, 반환 X
## 특화 함수형 인터페이스
- 의도를 명확하게 만든 특별한 함수형 인터페이스이다. 
### Predicate
- 입력 O, 반환 boolean
- 입력값을 받아 조건 충족 여부를 true, false로 구분하는 함수형 인터페이스이다('술어'라는 뜻이다). 
- 의도를 명확히 드러내기 위해 Function 대신 Predicate를 사용한다. 의미의 명확성을 가지고 가독성과 유지보수성을 향상시킨다.
### Operator
- 입력 O, 반환 O
- 덧셈 연산자, 곱셈 연산자, 논리 연산자 등을 가진다. 
- Function<T, T>를 상속받는다. 즉 입력 타입과 반환 타입이 동일하다. 
- Predicate와 동일하기 의미 명확성, 가독성, 유지보수성을 향상시킨다. 
## 기타 함수형 인터페이스
- 입력값이 2개 이상: ByXXX 시리즈
- 제네릭은 기본형 타입을 받을 수 없으므로 기본형을 지원하는 함수형 인터페이스가 존재한다. XXXFunction(IntFunction, BooleanFunction 등)
- 자바가 기본으로 제공하지 않는 함수형 인터페이스는 직접 작성해서 사용하자.

# 섹션 5: 람다 활용
### 명령형 프로그래밍 vs 선언적 프로그래밍
- 명령형 프로그래밍: 어떻게 수행해야 하는지 명시
  - 수행 절차를 명시
  - 단계별 과정
  - 상태 변화
  - 낮은 추상화
  - 시스템 상태, 흐름을 세밀하게 제어
- 선언적 프로그래밍: 무엇을 하고자 하는지 명시
  - 무엇을 수행해야 하는지, 원하는 결과 명시
  - 문제 해결에 집중
  - 코드 간결성, 의도 명확
  - 높은 추상화, 유지보수 용이
- 정적 팩토리 메서드: 객체 생성을 담당하는 static 메서드로 생성자 대신 인스턴스를 생성하고 반환하는 역할을 한다. 
  - 정적 메서드: 클래스 레벨에서 호출, 인스턴스 생성 없이 접근
  - 객체 반환: 내부에서 생성한 객체 반환
  - 생성자 대체: 생성자와 달리 메서드 이름 명시 가능
  - 유연한 구현: 캐싱, 객체 재활용, 하위 타입 객체 반환 등 다양한 로직 적용
- 내부 반복: 어떻게 순회할지는 스트림이 담당하도록 하여 생산성, 가독성을 높인다. 
- 단순한 반복이거나 반복 제어에 세밀한 조절이 필요한 경우는 외부 반복, 그 외에는 내부 반복을 사용하자. 

# 섹션 6: 람다 vs 익명 클래스
### 문법 차이
- 익명 클래스
  - 즉시 인스턴스화해서 사용, 인터페이스 명시와 오버라이드 필수
  - 여러 메서드를 가진 인터페이스 구현 가능
  - 오래된 자바 버전 호환 가능
  - this는 익명 클래스 자신을 가리킴
- 람다
  - 간결한 표현
  - 함수형 인터페이스만 구현 가능
  - 필드 가질 수 없음
  - this는 람다가 선언한 외부 클래스의 this를 가리킴
### 캡처링
- 익명 클래스
  - 외부 변수에 접근 가능하지만 지역 변수는 final 혹은 사실상 final 변수만 캡처 가능
- 람다
  - 지역 변수는 final 혹은 사실상 final 변수만 캡처 가능
### 생성 방식
- 익명 클래스
  - 새 클래스를 정의해 객체 생성
  - 컴파일 시 새로운 내부 클래스로 변환, 지정된 .class 파일 생성
  - 메모리 상의 약간의 추가 오버헤드
- 람다
  - 컴파일 타임에 .class 파일 생성 X, 런타임 시점에 동적으로 필요한 코드 처리
  - 메모리 효율적, 클래스 파일 관리 복잡성 감소
### 상태 관리
- 익명 클래스
  - 상태를 가질 수 있음(필드, 멤버 변수)
- 람다
  - 함수는 상태 없이 기능만 제공, 람다는 필드가 없으므로 상태 유지 X
### 용도
- 익명 클래스
  - 상태 유지, 다중 메서드 구현하는 경우
  - 기존 클래스, 인터페이스를 상속/구현할 때
  - 복잡한 인터페이스 구현 필요 시
- 람다
  - 상태 유지 필요 X, 간결함이 중요한 경우
  - 단일 메서드만 필요한 간단한 함수형 인터페이스 구현 시
  - 간결한 코드가 필요한 경우

# 섹션 7: 메서드 참조
- 메서드 참조가 필요한 이유: 이미 정의된 메서드를 람다가 호출하기만 하는 경우 코드 중복, 유지보수의 어려움
- **메서드 참조**: 이미 정의된 메서드를 그대로 참조하여 람다 표현식을 더 간결하게 작성하는 방법, `클래스명::메서드명`을 사용
  - 컴파일러가 자동으로 매개변수 매칭: 매개변수를 명시적으로 작성할 필요 없음
- 람다 작성 시 정의된 매개변수를 그대로 호출하는 경우에 사용하면 더 직관적이고 간결한 코드 작성 가능
## 메서드 참조의 유형
### 1. 정적 메서드 참조
- 정적 메서드를 참조
- `클래스명:메서드명`
### 2. 특정 객체의 인스턴스 메서드 참조
- `객체명::인스턴스 메서드명`
### 3. 생성자 참조
- `클래스명::new`
### 4. 임의 객체의 인스턴스 메서드 참조
- 첫 번째 매개변수(또는 해당 람다가 받을 대상)가 그 메서드를 호출하는 객체가 됨
- `클래스명(타입)::인스턴스 메서드명`
- 특정 타입의 인스턴스를 매개변수로 전달하면 해당 인스턴스의 인스턴스 메서드가 실행된다. 
- 첫 번째 매개변수는 메서드를 호출하는 실제 객체가 되고, 그 이후의 매개변수는 메서드의 실제 인자로 전달된다. 
### 특정 객체의 인스턴스 메서드 참조 vs 임의 객체의 인스턴스 메서드 참조
- 전자는 참조 정의 시 어떤 객체를 사용할지 정해져 있다. 즉 `객체명:메서드명`이다. 
- 후자는 해당 타입의 어떤 객체든지 사용할 수 있고, 참조 정의 시 객체가 지정되지 않는다. 즉 `클래스(타입)명:메서드명`이다.
- **메서드 참조에서 ()가 없는 이유**: ()는 메서드를 즉시 호출한다는 의미이다. 메서드 참조는 호출이 아니라 메서드의 이름으로 해당 메서드를 참조한다는 뜻이므로 ()가 들어가지 않는다.  
- **메서드 참조에서 매개변수를 생략하는 이유**: 함수형 인터페이스의 시그니처가 이미 정해져 있고, 컴파일러는 그 시그니처를 바탕으로 메서드 참조와 연결하기 때문에 명시적으로 작성하지 않아도 자동으로 추론되어 호출된다.

# 섹션 8: 스트림 API 1 - 기본
- 자바는 스트림 API로 스트림 관련 기능을 제공한다(I/O 스트림과 다르다).
## 스트림 API
- 데이터의 흐름을 추상화해서 다루는 도구이다. 
- 컬렉션, 배열 등의 요소들을 연산 파이프라인을 통해 연속적인 형태로 처리할 수 있도록 한다. 
### 스트림의 특징
1. 데이터 소스를 변경하지 않음(Immutable)
   - 원본 컬렉션 변경 없이 결과만 새로 생성
2. 일회성
   - 한 번 사용하면 새로 스트림을 생성
3. 파이프라인 구성
   - 중간 연산들이 이어지다가 최종 연산을 만나면 연산 수행, 종료
4. 지연 연산(Lazy Operation)
   - 중간 연산은 필요할 때까지 실제로 동작하지 않고 최종 연산 실행 시 한 번에 처리
5. 병렬 처리(Parallel)
  - 병렬 스트림을 쉽게 만들 수 있어 멀티코어 환경에서 비교적 단순한 코드로 작성 가능
### 일괄 처리 vs 파이프라인 처리
- MyStreamV3은 일괄 처리
- Stream API는 파이프라인 처리
- 일괄 처리(Batch Processing): 각 단계마다 결과물을 모아두고 전체가 끝난 뒤에야 다음 단계로 넘김
- 파이프라인 처리(Pipeline Processing): 하나의 제품이 여러 공정을 흐르듯이 쭉 통과, 모든 과정이 완료된 제품은 바로 종료
### 지연 연산
- 자바 스트림은 toList() 등과 같은 최종 연산이 호출되지 않으면 연산이 수행되지 않는다. 
- 즉시 연산: MyStreamV3은 중간 연산이 호출될 때마다 바로 연산을 수행
- 지연 연산: 꼭 필요할 때만 연산을 수행하도록 미룸, 최종 연산(terminal operation)을 만나야 본인이 가지고 있던 중간 연산 수행
  - 최종 연산을 만나면 조건을 만족하는 요소를 찾은 순간 연산을 멈추고 곧바로 결과를 반환하도록 최적화
  - 불필요한 연산 생략(단축; Short-Circuiting): 연산 중에 건너뛰어도 되는 부분 생략
  - 메모리 사용 효율: 중간 연산 결과 저장 필요 X
  - 파이프라인 최적화: 연산을 묶어 처리 가능, 중간 단계 저장 X

# 섹션 9: 스트림 API 2 - 기능
- 스트림 생성
### 중간 연산(Intermediate Operation)
- 스트림 파이프라인에서 데이터 변환, 필터링, 정렬 등을 하는 연산
- FlatMap: 각 요소를 스트림(또는 여러 요소)으로 변환한 뒤 그 결과를 하나의 스트림으로 평탄화(flatten)하는 것
### Optional
- Optional 클래스는 내부에 하나의 값을 가진다. 
- isPresent()는 그 값이 null인지 확인한다. 
- get()은 값을 반환한다. 
- Optional은 필수가 아니라는 뜻이다. 즉 값이 있을 수도 있고 없을 수도 있다. 
### 최종 연산(Terminal Operation)
- 스트림 파이프라인의 끝에서 호출되어 실제 연산을 수행하고 결과를 만들어내는 연산
- 최종 연산이 호출되면 그동안의 모든 중간 연산이 한 번에 적용되어 결과를 만든다. 
- 최종 연산을 한 번 수행하면 스트림은 재사용할 수 없다. 
### 기본형(primitive) 특화 스트림
- 자바는 IntStream, LongStream, DoubleStream 세 가지 형태를 제공해 기본 자료형에 특화된 기능을 제공한다. 
- 정수 관련 연산을 좀 더 편리하게 제공하고, 오토박싱/언박싱 비용을 줄여준다. 
- 성능
  - 전통적 for문이 가장 빠름
  - 전통적인 for문과 비교했을 때 기본형 특화 스트림은 비슷, 스트림은 1.5~2배 느림
- 실무 선택
  - 이런 성능 차이는 애플리케이션에서 별로 차이가 없음
  - 박싱/언박싱이 많이 없다면 성능 차이 별로 없음
  - 대규모 처리, 반복 횟수가 많은 경우 기본형 스트림이 효과적일 수 있음
  - 극단적인 상황이 아니라면 코드의 가독성과 유지보수성을 위해 스트림 API 사용

# 섹션 10: 스트림 API 3 - 컬렉터
# 섹션 11: Optional
# 섹션 12: 디폴트 메서드
# 섹션 13: 병렬 스트림
# 섹션 14: 함수형 프로그래밍